# Динамическое ДО. Персистентное ДО.

В [прошлой статье](https://github.com/kolychestiy/olymp/tree/main/segment_tree "базовое дерево отрезков") мы изучили что такое дерево отрезков, простой и быстрый способ его реализации, операции модификации на отрезке, способы применения. Перед изучением данной статьи рекомендуется приобрести знание этих вещей. 

Обозначения: 
1. $n$ $-$ размер массива
2. $q$ $-$ число запросов.
3. $a$ $-$ массив чисел размера $n$.
4. целевая функция $-$ функция, которая вычисляется на ДО, например сумма, минимум и т.д.

### Альтернативный способ реализации ДО

Если раньше, мы хранили только массив $t$ и красиво занумеровали вершины (у вершины $v$ дети это $2 \cdot v$ и $2 \cdot v + 1$), то сейчас сделаем некоторый шаг назад, чтобы потом сделать рывок вперёд. В рамках этой статьи нас будет интересовать наивная реализация, в которой мы для каждой вершины будем хранить её левого и правого ребёнка, в связи с чем напрашивается в том числе и создание отдельной стркуктуры для вершины:

```cpp
struct Node {
  Node *l = NULL;
  Node *r = NULL;
  int sum = 0;
};
```

Если что то из кода выше непонятно, то сначала стоит изучить [структуры в C++](https://www.guru99.com/ru/cpp-structures.html) и [указатели](https://metanit.com/cpp/tutorial/4.1.php). 

В таком случае соответсвующим образом изменятся `build`, `get` и `upd`:

```cpp
const int SZ = 1 << 17;
void build(Node *cur, int l = 0, int r = SZ){ 
    if (r - l == 1) { // лист
        // т.к. cur - указатель, то для обращения к левому ребёнку надо писать (*cur).sum
        // для таких целей в C++ есть специальный синтаксический сахар - cur->sum
        cur->sum = a[l];
        return;
    }

    int mid = (l + r) >> 1;
    cur->l = new Node; 
    build(cur->l, l, mid);
    cur->r = new Node;
    build(cur->r, mid, r);
    cur->sum = cur->l->sum + cur->r->sum;
}
```

```cpp
void upd(int i, int x, Node *cur, int l = 0, int r = SZ){
    if (i < l || r <= i){ // i не в ходит в [l, r)
        return;
    }

    if (r - l == 1){
        cur->sum = x;
        return;
    }

    int mid = (l + r) >> 1;
    upd(i, x, cur->l, l, mid);
    upd(i, x, cur->r, mid, r);
    cur->sum = cur->l->sum + cur->r->sum;
}
```

```cpp
int get(int ql, int qr, Node *cur, int l = 0, int r = SZ){
    if (qr <= l || r <= ql){ // [l, r) не пересекатся с [ql, qr)
        return 0;
    }

    if (ql <= l && r <= qr){ // [l, r) полностью входит в [ql, qr)
        return cur->sum;
    }

    int mid = (l + r) >> 1;
    return get(ql, qr, cur->l, l, mid) + get(ql, qr, cur->r, mid, r);
}
```

Остается только создать указатель на корень и сохранить его в переменной, для вставки в вызовы любой функции:

```cpp
  Node *root = new Node;
```

Минусы данной реализации очевидны - нам нужно больше памяти для хранения рёбер дерева, и также стоит ожидать несколько большее время работы, в виду скачков по памяти (есть реализации без указателей где эта проблема почти устраняется). Однако, как уже было сказано, мы пошли на столь отчаяный шаг чтобы сорвать куш. Данная реализация позволяет делать множество очень мощных модификаций.

## Персистентное ДО

Персистентные структуры данных (англ. persistent) — это структуры данных, которые при внесении в них каких-то изменений сохраняют все свои предыдущие состояния и доступ к этим состояниям.

Говоря более простым языком: После каждого `upd` мы хотим сохранять старую версию ДО, чтобы можно было с ней работать, в том числе делать на ней `get`. 

Для лучшего понимания, рассмотрим задачу. [Условие задачи в контесте](https://codeforces.com/group/fgAhCx6Kz6/contest/506298/problem/A "based contest. task A"). Приведём сжатое условие и здесь: Есть запросы вида $[l, r]$. Нужно находить $k$-ю порядковую статистику среди $a_l, a_{l+1}, \ldots, a_r$.

Для начала научимся решать задачу, описанную в [прошлой статье](https://github.com/kolychestiy/olymp/tree/main/segment_tree "базовое дерево отрезков") в разделе `"Спуск" по дереву.`. Представим теперь, что мы для каждого запроса построили такое ДО только на элементах из отрезка $[l, r]$. Тогда мы умеем отвечать на запрос за $\mathcal{O}(\log n)$. 

Введём операцию сложения двух ДО. $t_{fi}$ и $t_{se}$ $-$ 2 ДО одинакового размера, тогда $t_{res} = t_{fi} + t_{se}$ это ДО такого же размера как и слагаемые, при этом $t_{res}[v] = t_{fi}[v] + t_{se}[v]$ для любого $v$.

Обозначим ДО для отрезка $[l, r]$ как $t_{l,r}$, а ДО для отрезка $[0, r]$ как $t_r$. Справедливо следующее удтверждение: $t_{l,r} = t_r - t_{l - 1}$. Таким образом, Достаточно построить $t_i$, для всех $0 \le i \le n$, и через них выражать любое $t_{l, r}$. Это по сути есть ничто иное, как массив префиксных сумм, элементами которого являются ДО. В тривиальной реализации это займет $\mathcal{O}(n^2)$ времени и столько же памяти.

Поэтому давайте мы не будем строить новое ДО каждый раз, а будем по хитрому использовать ДО построенное на предыдущем шаге. $t_r = t_{r-1} + t_{r,r}$, а поскольку $t_{r,r}$ $-$ это по сути один раз выполненная функция `upd`, то $t_{r,r}$ имеет $\mathcal{O}(\log n)$ ненулевых вершин, а следовательно $t_r$ отличается от $t_{r-1}$ не более чем в $\mathcal{O}(\log n)$ вершинах. Поэтому, $t_r$ может подобно паразиту использовать для своей жизни $t_{r-1}$, создавая на нём не более $\mathcal{O}(\log n)$ ~~раковых клеток~~ новых вершин. Этими вершинами будут в точности те вершины, которые мы изменили. Они изначально будут полностью копировать своих предшественников, но потом поменяют своё значение целевой функции(суммы) и ссылки на каких то детей, которые тоже могли быть обновленны. Таким образом, Учитывая то, что мы написали ДО на указателях, для того чтобы работать с $t_r$ достаточно хранить указатель на его корень, который был получен после внесения изменений в $t_{r-1}$.

Упрощая всё вышесказанное. Каждый раз, когда мы делаем `upd`, все вершины, в которые мы зайдем в процессе выполнения функции будем просто клонировать, и работать всегда с клоном, сохраняя старую версию вершины для предыдущих версий. При клонировании также не будем забывать менять ссылки со старых на новые вершины. Для лучшего понимания приведём код:

```cpp
// функция теперь возвращает указатель на клонированную вершину.
// или на старую, если клонирования не произошло (нет никаких изменений в вершине)
Node* upd(int i, int x, Node *cur, int l = 0, int r = SZ){
    if (i < l || r <= i){
        return cur;
    }

    cur = new Node (*cur); // клонирование. применим конструктор копирования,
    // который создаст новую переменную, скопировав в неё все из старой
    if (r - l == 1){
        cur->sum = x;
        return cur;
    }

    int mid = (l + r) >> 1;
    // обновляем ссылки
    cur->l = upd(i, x, cur->l, l, mid);
    cur->r = upd(i, x, cur->r, mid, r);
    cur->sum = cur->l->sum + cur->r->sum;
    return cur;
}
```

Изменим `kth` из прошлой статьи:

```cpp
int kth(Node *tl, Node *tr, int k, int l = 0, int r = SZ){
    if (r - l == 1){
        return l;
    }

    int mid = (l + r) >> 1;
    int S = tr->l->sum - tl->l->sum;
    if (S >= k){
        return kth(tl->l, tr->l, k, l, mid);
    }
    return kth(tl->r, tr->r, k - S, mid, r);
}
```

Вся логика функций осталась неизменной, поэтому и `upd` и `kth`$/$`get` работают за $\mathcal{O}(\log n)$ для персистеного дерева отрезков. Однако, изменились затраты по памяти. Теперь вместо $\mathcal{O}(n)$ памяти, с каждым запросом, где создаются клонированные вершины, будет добавляться $\mathcal{O}(\log n)$ памяти, в связи с чем общая оценка занимаемой памяти составляет $\mathcal{O}(n + q \cdot \log n)$.

Персистентное дерево отрезков имеет весьма интересные и различные способы применения, которые к сожалению не уместить в рамках данной статьи. Из важного стоит добавить, что данный подход для перехода к персистентности применяется во многих структурах данных.

## Жидкое ДО. Оно же неявное ДО. Оно же динамическое ДО. Оно же ДО с отложенным построением.

Вспомним классическую задачу суммы на отрезке. А теперь представим себе, что мы имеем массив очень большой длины (например $10^9$ или $10^{18}$ вместо классических $10^5$. Казалось бы, время работы операций на ДО $\mathcal{O}(\log n)$ нас всецело устраивает, т.к. даже для $10^{18}$ это всего лишь порядка 60 операций. Но вот `build` нас немного подкачал, т.к. его время работы $\mathcal{O}(n)$, и памяти занимает столько же. В связи с этим от построения дерева отрезков нам предётся отказаться и выкручиваться без явно построенного дерева. 

Решается эта проблема достаточно легко $-$ будем создавать вершину только тогда, когда значение в ней впервые изменится и перестанет быть равным дефолтному (обычно $0$). Если вершины не существует, пологаем что она и всё её поддерево имеют дефолтные значения. Можно провести аналогию с ленивыми операциями модификации на отрезке, и даже иногда полезно вынести логику проверки и создания детей вершины в `push` (черевато лишними затратами памяти).

Таким образом будет затрачиваться $\mathcal{O}(q \cdot \log n)$ памяти, с сохранением времени работы для всех операций. Персистентное ДО можно тоже строить неявно, что также экономит память.

Перед тем, как рассмотреть реализацию, затронем один не маловажный момент. Вместо реализации на указателях почти всегда выгоднее по времени работы и затрачиваемой памяти получается реализация на массиве. В такой реализации мы заранее создаём массив содержащий достаточное число вершин на всё время работы программы, после чего создавая новую вершину, берём вершину с наименьшим индексом из массива, которая еще не занята (кроме индекса $0$, его удобно использовать как индикатор отсутствия вершины). 

Таким образом вместо 8 байт памяти, которые занимает указатель, мы будем тратить 4, если хранить индекс в `int`, иногда можно хранить даже например в `short int` или вовсе тратить нестандартное число бит для хранения значения (автор сдавал таким образом несколько задач, требующих либо адекватной идеи, либо затолкать с двух ног толстую структуру данных). Также используя массивы мы имеем монолитную полоску в памяти, где хранятся наши данные, за счёт чего может уменьшиться время затрачиваемое на прыжки по памяти. 

Поэтому для демонстрации этой методики приведём реализацию неявного ДО на массивах:

```cpp
const int sz = 30;
// большой размер ДО
const long long SZ = 1ll << sz; 
 
struct Node {
    int l = 0;
    int r = 0;
    long long sum = 0;
};
 
int cnd = 1; // номер вершины, которую можно начать использовать
Node nd[MXQ * sz]; // MXQ - максимальное число запросов. Таким образом,
// если создавать не более sz вершин на каждом запросе этого достаточно
// но зачастую нужно будет например 2*sz а при плохих реализациях и того больше.
// важно уметь очень чётко считать затрачиваемую память и число создаваемых вершин,
// а так-же стараться не создавать лишних вершин.
 
int root = cnd++;
```

```cpp
// альтернативный подход. вместо возвращения вершины результатом функции
// будем передавать значение по ссылке, что немного упрощает реализацию
// (это можно сделать и в реализации на указателях, вот так: Node* &cur)
void upd(int &cur, long long i, long long x, long long l = 0, long long r = SZ){
    if (i < l || r <= i){
        return;
    }

    // создадим вершину только перед тем как начать с ней работать,
    // а не в самом начале тела функции
    if (!cur){
        cur = cnd++;
    }
    nd[cur].sum = x;
 
    if (r - l == 1){
        return;
    }
 
    long long mid = (l + r) >> 1;
    upd(nd[cur].l, i, x, l, mid);
    upd(nd[cur].r, i, x, mid, r);
}
```

```cpp
long long get(int cur, long long ql, long long qr, long long l = 0, long long r = SZ){
    if (qr <= l || r <= ql || !cur){
        return 0;
    }
 
    if (ql <= l && r <= qr){
        return nd[cur].sum;
    }
 
    long long mid = (l + r) >> 1;
    return get(nd[cur].l, ql, qr, l, mid) + get(nd[cur].r, ql, qr, mid, r);
}
```

### Число вершин в неявном ДО.

Сделаем оценку сверху на число вершин в ДО по итогу выполнения всей программы. `upd` изменяет значения в точности на каком-то пути вниз от корня до листа (и если и создаёт новые вершины, то только на этом пути), из чего делается вывод, что максимальное число вершин которые он может изменить $\log_2 n + 1$. `get` же не создаёт ни одной новой вершины, поскольку при отсутствии вершины мы понимаем, что там дефолтные значения. Таким образом, максимальное число вершин можно оценить сверху как $q \cdot (\log_2 n + 1)$.

Выведем эту оценку немного иным способом. На каждом уровне ДО вызов `upd` порождает не более одной вершины. Из этого следует таже самая оценка. Но вспомним что в ДО на $i$-м уровне находится $2^i$ вершин (корень на $0$-м уровне). На каждом уровне мы можем создать не более чем $\min(q, 2^i)$ вершин. Получаем, что первые $\lfloor \log_2 q \rfloor + 1$ уровней порождают по $2^i$ вершин, и оставшиеся $\log_2 n - \lfloor \log_2 q \rfloor$ уровней породят по $q$ вершин. Поэтому более точной оценкой максимального числа вершин будет $q \cdot (\log_2 n - \lfloor \log_2 q \rfloor) + 2^{\lfloor \log_2 q \rfloor + 1} - 1$ или если $q$ степень двойки, то будет куда проще: $q \cdot (\log n - \log q + 2) - 1$. 

### Сжатие координат.

Жидкое ДО имеет 2 значительных недостатка $-$ время и память. Да и иногда проще написать явное ДО, которое будет лучше по всем параметрам. И выход есть! Если все запросы известны заранее, то есть обрабатываются в оффлайне, то можно сжать все числа являющиеся границами (или координатами) при запросах на ДО, для отказа от неявного ДО.

Идейно сжатие $-$ это функция, сопоставляющая каждой исходной координате (границе запроса) некоторое число. При этом числа у разных координат должны быть различны, а поскольку нам важен относительный порядок координат, то у большей координаты должно быть большее сжатие. И конечно, желательно минимизировать максимальное значение функции сжатия, поэтому обычно разница между соседними значениями будет еденица.

Сжатие можно делать различными способами, например с помощью `map`, но она имеет большую константу, поэтому воспользуемся сортировкой и бинпоиском по отсортированному массиву (есть встроенный `lower_bound`):

```cpp
vector<int> p;
// ...
// положим в p все координаты, которые нужно сжать
// ...
sort(all(p));
p.resize(unique(p.begin(), p.end()) - p.begin()); // удалим все повторения
```

Теперь $p$ содержит все координаты в отсортированном виде. Чтобы сжать координату $i$ нужно просто найти её позицию в массиве:

```cpp
int j = lower_bound(p.begin(), p.end(), i) - p.begin();
```

Заметим, что необязательно закидывать в $p$ все координаты. Запросы, не модифицирущие ДО часто выгодно не вносить в список сжимаемых координат (Но будьте с этим очень осторожны и вдумчивы!).
