# Sqrt-декомпозиция (так же называют корневая декомпозиция, корнячка). Часть 1.

## Суперкратко об этом readme

Конкретно в этом readme не буду описывать подробно всё, что будет на семинаре, потому что не вижу смысла переписывать чужие статьи, на которые будут ссылки ниже.

## Предисловие

Однако стоит начать, как мне кажется, с более плавного введения, чем где-либо я это видел.

Во-первых, что такое декомпозиция? _Декомпозиция — операция мышления, состоящая в разделении целого на части_ (Википедия). Если вы имеете хоть небольшой опыт в программировании, то может показаться, что термин _Декомпозиция_ подходит в нашей сфере под многие вещи: мы очень часто делим одну большую задачу на несколько маленьких. Бывает даже так, что на такие же - вспомните подход в динамического программирования.

Однако, декомпозия подразумевается здесь несколько в ином смысле. Подразумевается, что мы делим некий целый объект на независимые кусочки, чтобы потом всё заработало вместе. Как, например, это происходит в микросервисной архитектуре приложений. 

Во-вторых, что такое именно корневая декомпозиция? Это довольно общий подход, при котором мы при решении задачи над некоторым множеством разделяем последнее на несколько подмножеств и решаем задачу уже для них, при котором тут или там появляется квадратный корень из чего-нибудь.

Очень размыто и абстрактно? Согласен. Однако я надеюсь, что такое предисловие позволило вам понять, что корнячка - это не просто стркутура данных или конкретный алгоритм, а целый подход при решении задач.

## Даже разберу задачу (правда, которую вы все и так умеете решать)

Вспомним практически самую простую задачу из области алгоритмов: дано число натуральное $n$, нужно найти все его делители. Вспомним самый простой из известных способов факторизации:

```cpp
vector<int> getAllDivisiors() {
    vector<int> divs;

    for (int i = 1; i * i <= n; i++) {
        if (n % i == 0) {
            divs.push_back(i);
            if (i * i != n) {
                divs.push_back(n / i);
            }
        }
    }

    return divs;
}
```

Конечно, когда вам в самом начале постижения алгоритмов рассказывали про этот способ факторизации, никто не упоминал корневую декомпозицию. Однако, давайте посмотрим чуть внимательнее на то, что здесь происходит. Здесь мы выделяем "маленькие" делители (которые $\le \sqrt n$) и "большие" (которые $> \sqrt n$). Мы точно знаем, что маленькие делители мы можем перебирать не вплоть до $n$, а лишь вплоть до $\sqrt n$ ввиду самого определения. В то время как большие мы перебирать не можем, однако мы можем их вычислить, используя маленькие.

Это довольно общий подход, когда мы выделяем в задаче "маленькие" и "большие" объекты, а затем по-разному для них считаем ответ. Этому подходу мы обязательно выделим время.

На этом введение окончено. Далее перечислю список того, что я планирую разобрать на семинаре, а так же кину ссылки на статью, где про это можно почитать.

## В планах на семинаре:

1. Деление на тяжелые и легкие объекты (разберём базовые задачи: количество треугольников в графе, https://codeforces.com/contest/710/problem/F без Ахо-Корасика);
1. Корневая декомпозиция как структура данных;
1. Корневая по запросам;
1. Алгоритм Мо в базовом варианте;
1. Разберем задачу https://codeforces.com/contest/13/problem/E.

## Ссылка
Где про всё это можно почитать: https://algorithmica.org/ru/sqrt. Ссылки на разборы задач найдете в этой же статье. Отмечу лишь то, что коду на алгоритмике доверять не стоит, потому что зачастую он написан с багами, либо вообще не компилируется. Однако в этой статье, кажется, таких проблем обнаружено не было.

## Конец?
Нет, не конец. Будет ещё второй семинар, посвященный корневой оптимизации, в котором рассмотрим уже более интересные штуки, про некоторые из которых толком в тырнетах на русском не написано.

