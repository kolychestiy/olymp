# Хеширование строк.

## Актуальность.

Задача: Есть $n$ слов $s_i$, нужно уметь сравнивать произвольные $s_i$ и $s_j$ (например лексикографически). Пусть $S = \sum_{i=1}^n |s_i| \le 10^6$. 

Посимвольное тривиальное сравнение работает за $\mathcal{O}(\min(|s_i|, |s_j|))$. Попробуем предподсчитать все пары значений заранее, и дальше отвечать на запрос за $\mathcal{O}(1)$. Пусть $n = 10^3$ и $|s_i| = 10^3, \forall i \in [1, n]$. Тогда для каждой отдельной строки нужно сопоставить ей все остальные, что составит по времени $\mathcal{O}(S)$, следовательно для всех пар строк будет $\mathcal{O}(S \cdot \sqrt S)$. Можно быстрее. 

Или вот ещё задача: Есть строка $s$, нужно уметь сравнивать любые $2$ её подстроки, быстрее чем тривиально.

Эти и многие другие задачи помогут решить хеши.

## Хеш-функция

*Хеш-функция* $-$ функция, сопоставляющая некоторым типам объектов число. 

Основной целью хеш-функции является возможность проверки двух объектов на равенство.

Например, мы хотим функцию $h$, сопоставляющую массиву из $2$-х чисел одно число. Приведём несколько примеров такой функции:

$h_1([a, b]) = a + b$

$h_2([a, b]) = (37 \cdot a^2 + 5 \cdot b) \% (10^9 + 7)$

$h_3([a, b]) = 1$

Все $3$ приведённые функции являются хешами (хеш-функциями). Понятно, что $h_3$ не имеет никакого смысла, поскольку результат её никак не зависит от входных данных.

Говоря про $h_1$ можно заметить, что для некоторых различных $[a_1, b_1]$ она сопоставит одинаковый хеш. Например $h_1([3, 7]) = 10$ и $h_1([-2, 12]) = 10$. Здесь необходимо ввести второе важное определение, описывающее это поведение:

*коллизия* $-$ Ситуация, при которой для двух различных параметров совпадают их хеши.

Учитывая основную цель хеш-функции, коллизии необходимо сводить к минимуму. Беря в расчёт коллизию, можно сказать что во многих ситуациях $h_2$ будет предпочтительнее $h_1$. Но здесь необходимо оценивать вероятность коллизии в каждой конкретной задаче отдельно.

Зачем в $h_2$ необходимо брать результат по модулю? В целях повышения производительности. Если хеш будет слишком большой, то смысл в нём будет исчерпываться, поскольку тогда проще будет прибегнуть к тривиальному сравнения объектов между собой.

Резюмируем основные требования к хеш-функции:

* Хеш-функция должна позволять эффективно по времени и памяти реализовывать сравнение хешируемых объектов.

* Хеш-функция должна стремиться уменьшить вероятность возникновения коллизии.

И вот, $2$ перечисленных требования вступают в борьбу между собой. Необходимо грамотно балансировать между ними.

Заканчивая вводную часть по хеш-функциям стоит добавить, что в качестве хешируемого объекта может выступать почти что угодно. Строка, массив чисел, граф, дерево, некоторый класс или структура. Потенциал хеш-функций огромен, и выходит далеко за пределы рассматреваемой здесь темы.

## Полиномиальное хеширование строк

Рассмотрим некоторые примеры хеш-функции для строки. Положим $s = s_1 s_2 \ldots s_n$ (строка из $n$ пронумерованных символов). Полезно будет обозначить число символов в используемом алфавите за $m$.

Под $s_i$ понимается компьютерное представление символа. В компьютере вся информация, в т.ч. и символы, хранится как некоторый набор битов, и потому обычно легко представима в виде числа. В случае с символами, существуют кодировки, сопоставляющие каждому числу в кодировке некоторый символ. Буквы, цифры и некоторые другие символы, принято распологать по порядку. Поэтому в С++ выражение `c - 'a'`, гдее `c` $-$ переменная типа `char`, можно интерпретировать как порядковый номер буквы в алфавите, а выражение `c - '0'` $-$ вернёт истинное значение цифры, вместо её символьного кода.

* $h_1(s) = s_1 + s_2 + \ldots + s_n$

Данную хеш функцию можно считать высоко-коллизийной. Во первых она никак не учитывает порядок букв в строке, потому $h("abc") = h("cab")$. Так-же имеем следующую ситуацию: $h("ad") = h("bc")$. Если сказать, что 'a' имеет код $0$, то получим что $h("bc") = h("d")$. 

Наконец, давайте произведём оценку вероятности возникновения коллизии, при условии что обе строки имеют длину $n$ и каждая выбрана случайно (каждый символ равновероятно выбирается из $m$ имеющихся символов алфавита). Тогда $h_1(s) \in [0, n \cdot m)$, всего $n \cdot m$ допустимых значений. Из предположения равновероятности распределения значения среди всех строк (что кстати совершенно неверно) получим, что вероятность коллизии есть $\frac{1}{n \cdot m}$. Данная формула полезна, для оценки вероятности коллизии на строках малой длины (с поправкой на неравное распределение, она становится ещё хуже).

Обобщая $-$ $h_1$ очень плохая хеш-функция. Давайте будем хоть как-то учитывать порядок букв. Возьмём некоторый массив чисел $a$ и посмотрим на такую функцию:

* $h_2(s) = s_1 \cdot a_1 + s_2 \cdot a_2 + \ldots + s_n \cdot a_n$

Поскольку $h_1$ является частным случаем $h_2$ делаем вывод, что массив должен быть не абы-какой. Можно генерировать значения случайным образом, и если промежуток для генерации достаточно велик (например $a_i \in [0, 10^9]$) Вероятность коллизии нашей хеш-функции становится весьма приемлимой.

Но можно ещё лучше, если взять конкретные $a_i$. Строку на алфавите размера $m$ на самом деле можно представить как число в системе счисления по основанию $b > m$. Потому появляется следующая функция:

* $h_3(s) = s_1 + s_2 \cdot b + s_3 \cdot b^2 + \ldots + s_n \cdot b^{n - 1}$

$h_3$ принято называть полиномиальным хешом, поскольку она является палиномом степени $n - 1$ относительно $m$. 

Данная хеш-функция **безколлизийна** (при условии что наименьший символ алфавита имеет ненулевой код, иначе $h_3("b") = h_3("ba")$, имея ввиду ведущие нули). Никто не станет спорить, что цифровая запись числа в некоторой системе счисления не может обозначать сразу несколько чисел. Однако отсутствие коллизий не единственное преимущество данной функции. Забегая наперёд, с её помошью можно быстро вычислять хеш любой подстроки.

Работая со строками обычно используют именно полиномиальный хеш.

## Эффективность

Мы достигли совершенства в одном из двух предложенных нами требований к хеш-функции, полностью избавившись от коллизий, но имеем эффективность, ассимптотически не лучше чем тривиальное сравнение строк (размер полиномиального хеша прямо пропорционален размеру строки, и длинная арифметика будет работать не сильно быстрее).

Для этого будет достаточно производить вычисления по некоторому модулю. Поскольку мы стремимся делать вычисления эффективно, все вычисления нужно производить используя базовые целочисленные типы данных. Но если взять модуль слишком маленьким (например 100), получим высокую вероятность коллизии. Потому модуль стоит брать максимально возможным, но не переполняющим используемый тип данных при вычислениях. По итогу имеем хеш-функцию вида:

* $h(s) = (s_1 + s_2 \cdot b^1 + \ldots + s_n \ldots b^{n-1}) \% mod$

Важно отметить, что в хорошеё хеш-функции $\gcd(b, mod) = 1$. Если это не так, то $b^x$ будет принимать не все возможные значения. Если же $rad(x) = rad(mod)$ (см. https://ru.wikipedia.org/wiki/Радикал_целого_числа) то и вовсе $b^x$ быстро выродится в $0$.

Из предположения равновероятного распределения значений хеша (что является правдой при $b$ примерно равному $m$) среди строк, получаем вероятность коллизии при одном сравнении $\frac{1}{mod}$. Вероятность коллизии для строк малой длины и вовсе равна $0$.

### подстроки

Как было заявлено в актуальности, хешами можно сравнивать подстроки. Пусть $s_{l-r} = s_l s_{l+1} \ldots s_r$. Воспользуемся идеей, аналогичной префиксным суммам. Давайте вычислим хеши всех префиксов строки:

* $h_r = h(s_{1-r})$

Тогда вычисление хеша подстроки:

* $h(s_{l-r}) = ((h_r - h_{l-1}) \cdot b^{-l+1}) \%mod$

Однако брать обратное к $b$ по модулю вовсе не обязательно. Для этого можно домножить функцию на $b^{SZ}$, где $SZ$ $-$ максимальная длина строки, тогда умножение на обратное делать будет вовсе не обязательно:

* $h(s_{l-r}) = ((h_r - h_{l-1}) \cdot b^{SZ-l+1}) \%mod$

### $mod = 2^{64}$

У этого модуля практически нет недостатков. Он очень большой (больше уже не влезает в `unsigned long long`) и реализационно он сильно упрощает код и скорость вычислений. Достигается это, за счёт того, что `unsigned long long` по умолчания проводит вычисления по модулю $2^{64}$. Рассмотрим пример реализации:

```cpp
#define ull unsigned long long

const int SZ = 1e5 + 5;
const ull b = 27;
ull p[SZ]; // p[i] = b^i

// строит префикс-хеши
vector<ull> build_h(string s){ 
    vector<ull> h(s.size() + 1);
    for (int i = 0; i < s.size(); i++){
        h[i + 1] = h[i] + (s[i] - 'a' + 1) * p[i];
    }
    return h;
}

ull get_h(int l, int r){
    return (h[r] - h[l - 1]) * p[SZ - l]; 
    // аккуратно, p[i] не должно выходить за пределы массива
}

main(){
    p[0] = 1;
    for (int i = 1; i < SZ; i++){
        p[i] = p[i - 1] * b;
    }

    // ...
}
```

Получаем $\mathcal{O}(|s|)$ времени и памяти на предподсчёт и $\mathcal{O}(1)$ времени ответа на запрос. Асимптотически оптимальное решение, для проверки двух подстрок на равенство.

Однако есть один весомый недостаток - строка Туэ-Морса: https://neerc.ifmo.ru/wiki/index.php?title=Слово_Туэ-Морса. Она вызывает огромное колличество коллизией для хеша с $mod = 2^k$. Потому, если авторы задач захотят, они могут добавить контртесты на данный хеш. Но, такое происходит достаточно редко.

### $mod$ простое число

В качестве $mod$ можно использовать большое простое число. Вообще часто при работе по модулю, лучше когда он простой. так например при простом $mod$ можно выбрать любое $0 < b < mod$, т.к. $\gcd(b, mod) = 1$. Самым известным в кругах олимпиадников модулем является $10^9 + 7$. Иногда можно встретить $10^9 + 9$. оба эти числа $-$ простые. При необходимости, можно самостоятельно найти случайное больше простое число.

Почему числа порядка $10^9$, а не $10^{18}$? В процессе вычислений нам необходимо перемножать, и для того, чтобы не переполнять `long long` и выбираются такие относительно небольшие модули. Важно при работе по модулю не забывать ставить модуль в каждом месте, где потенциально может произойти переполнение, и например не забывать, что в C++ модуль от отрицательного числа берётся не по математическим правилам (в целях оптимизации). Потому отрицательное число сначала нужно сделать положительным, а потом уже брать от него модуль.

```cpp
#define ll long long

const int SZ = 1e5 + 5;
const ll b = 27;
const ll mod = 1e9 + 7;
ll p[SZ];

vector<ll> build_h(string s){ 
    vector<ll> h(s.size() + 1);
    for (int i = 0; i < s.size(); i++){
        h[i + 1] = (h[i] + (s[i] - 'a' + 1) * p[i]) % mod;
    }
    return h;
}

ull get_h(int l, int r){
    return (h[r] - h[l - 1] + mod) * p[SZ - l] % mod; 
}

main(){
    p[0] = 1;
    for (int i = 1; i < SZ; i++){
        p[i] = p[i - 1] * b % mod;
    }
}
```

### Парадокс дней рождений

Про него хорошо написано здесь, в конце статьи: https://algorithmica.org/ru/hashing. 

Стоит добавить, что парадокс дней рождений для оценки числа коллизий в задачах нужно применять аккуратно. Во первых строки можно сначала сравнивать по длине, а потом по хешу. И часто, в рамках решения задачи само собой сравниваются только строки одинаковой длины, при том что сравнений строк каждой конкретной длины происходит гораздо меньше, чем суммарное число сравнений. Стоит учитывать и то, что коллизия может случится не повлияв на ответ на задачу. Потому достаточно часто хватает одного модуля порядка $10^9$. 

Но всё же не всегда, и на такой случай есть $2$ способа решения: перейти на модуль $2^{64}$ либо же проверять хеши по $2$-м различным модулям (из соображений безопасности можно брать различные $b$ к каждому из модулей).

Сравнение двух хешей может давать только ложно-положительный ответ (если хеши различны, то объекты точно различны). Потому условием равенства объектов становится равенство хешей одновременное по $2$-м модулям. Вероятность коллизии при этом просто перемножается, от чего больше чем $2$ модуля использовать смысла обычно не имеет (вероятность коллизии порядка $\frac{1}{10^{18}}$)

По реализации можно посоветовать функции `build_h` и `get_h` получающие парамер `mod` или же создать структуру (или использовать `pair`) и переопределить операторы `+`, `-`, `*`, `%`.

### Взломы на codeforces

Поскольку хеши имеют коллизии, то сдавать решение основанное на хешах в условиях, когда контр-тест могут подбирать конкретно против вашего решения - дело рисковое. Старайтесь избегать решений с хешами на codeforces, а если всё же придумали оное, то постарайтесь либо сделать его безколлизийным (например такой хеш есть для деревьев https://codeforces.com/blog/entry/113465), либо генерируйте модуль случайно на каждом запуске (Для случайной генерации рекомендуется не использовать ключ генерации `time(0)`, ушлые взломщики могут подобрать тест под опредлённый момент времени запуска. Вместо этого используйте например `random_device{}()`. Также не рекомендуется использование `rand()`, лушче `mt_19937`.)

### Резюме

Хеши - очень универсальный инструмент, для решения строковых задач. Главный их недостаток - время работы. Конечно, в задаче на проверку равенства двух подстрок им почти нет равных, но в более сложных задачах хеши часто оказываются неоптимальны по времени работы, по сравнению с каким нибудь специализированным строковым алгоритмом.
