# Дерево отрезков. Оно же ДО.

### Задача
Решим такую задачу. Есть массив $a_0, a_1, \ldots , a_{n-1}$ из $n$ чисел. Нужно уметь обрабатывать за быстро ( $\mathcal{O}(\log n)$ ) 2 типа запросов:

1. Даны $l$ и $r$. Найти $\Sigma_{i=l}^{r} a_i$
2. Даны $i$ и $x$. Сделать $a_i = x$

Если решать задачу без второго запроса, то можно с помощью префиксных сумм отвечать за $\mathcal{O}(1)$ на первый тип запросов. Однако если бы мы захотели обрабатывать еще и обновления в массиве, то нам каждый раз пришлось бы перестраивать массив префикс сумм за $\mathcal{O}(n)$ для обработки второго запроса. Для устранения сей несправедливости применим дерево отрезков.

### Идея

Разбить массив на множество отрезков $T$ (отрезки могут пересекаться и включать один в другой). Для каждого отрезка хранить значение суммы чисел на нём так, чтобы для ответа нужно было насуммировать значения из $\mathcal{O}(\log n)$ отрезков, а для обновления нужно было изменить значения $\mathcal{O}(\log n)$ отрезков.

Будучи умными и адекватнемы людьми, будем работать в дальнейшем не с отрезками $[l, r]$, а с полуинтервалами $[l, r)$ (правая граница не включительно). Так принято и в C++ и так действительно очень удобно решать многие задачи.
Так же для удобства будем считать, что $n = 2^k$, для некоторого целого $k$. Если массив имеет неподходящий размер - заполним его нейтральными элементами относительно сложения (нулями) до ближайшей степени двойки.

Очевидно, что нам необходимо включить в $T$ все отрезки вида $[i, i+1)$. Отобразим их графически друг за другом. Таким образом, отображённое ниже множество отрезков по сути является самим исходным массивом.

![](segtree1.svg)

А теперь давайте включим в $T$ все отрезки вида $[i, i+2)$, $i \mod 2 = 0$. Иными словами, сгруппируем элементы по 2 в исходном массиве, получим новый, внесём новый массив в $T$.

![](segtree2.svg)

Включим также и отрезки вида $[i, i+4)$, $i \mod 4 = 0$. Или по аналогии продолжая группировку массива по парам соседних элементов, только уже от шага с отрезками $[i, i+2)$.

![](segtree3.svg)

Итоговый алгоритм выбора отрезков включенных в $T$: все отрезки удовлетворяюшие требованию $[i, i+2^k)$, $i \mod 2^k = 0$.

![](segtree4.svg)

Лемма: число "уровней" в данной конструкции в точности $k$, если $n = 2^k$, что по сути $\log_2 n$. Отсюда получаем что высота конструкции $\mathcal{O}(\log n)$. Док-во: изначально $n$ элементов на уровне, каждый следующий делит их число на $2$.

Из данной леммы очевидно, что при запросе второго типа нам нужно обновить значение суммы для $\mathcal{O}(\log n)$ отрезков, так как на каждом уровне каждый элемент массива входит ровно в $1$ отрезок (отрезки на одном уровне не пересекаются, а их объединение образует отрезок равный всему массиву).

Пример для запроса обновления в позиции $11$ (синим выделены те отрезки, значение которых надо обновить):

![](segtree_q2.svg)

Для запроса первого типа достаточно насуммировать значения из $\mathcal{O}(\log n)$ отрезков. Давайте рекурсивно спускаться по уровням вниз, при этом на текущем уровня стараясь взять как можно больше отрезков, но не беря те части, которые уже были взяты где-то уровнем выше. Тогда получится, что на каждом уровне мы возьмем значение не более двух отрезков. Доказывать это прямо сейчас нет смысла, это будет более понятно после описания процедуры взятия суммы на отрезке.

Пример для запроса $[3, 11)$ (синим - отрезки с которых берём значение суммы, серым - вроде бы интересующие, но включенные в отрезки на более высоком уровне):

![](segtree_q1.svg)

### А при чём тут дерево?

Напомню, что структура данных называется деревом отрезков. Вершинами этого дерева являются отрезки из множества $T$. Рёбра проводятся между элементами соседних уровней, и обозначают включение одного отрезка в другой. Таким образом, получается у всех вершин в точности 2 ребёнка, кроме листовых.

![](sg1.svg)

Рассмотрим наконец конкретный пример. Задан массив: $[3, 7, 2, 1, 6, 4, 7]$. Сейчас $n = 7$, для успешного построения ДО добавим в конец ещё нулей до ближайшей степени $2$ (сделаем $n = 8$): $[3, 7, 2, 1, 6, 4, 7, 0]$. В самом массиве эти нули можно не добавлять, но при построении и использовании ДО с ними будет куда проще. Приведём же наконец дерево отрезков на сумму, построенное для данного массива. Для начала заполним значения в листах. Для этого просто перенесём туда значения из массива:

![](sg2.svg)

Дальше каждый следующий уровень дерева строится простым суммированием значений в детях:

![](sg3.svg)

![](sg4.svg)

Заметим, что можно строить как рекурсивно сверху вниз (запуститься из корня, сказать что сумма в нём это сумма в левом и правом ребенке, запустить рекурсивное вычисление в его детей, и т.д. до листов, а в них записаны числа из массива для базы рекурсии), так и идя снизу вверх, как и показано на рисунке (о том, как это делать сказано немного ниже).

### А как это реализовать?

Конечно сделать это можно несколькими способами, но мы рассмотрим классический - будем хранить дерево в массиве. Для этого нам желательно придумать хорошую индексацию вершин, позволяющую быстро и лаконично реализовывать ДО. Для этого достаточно сказать что корень дерева имеет индекс $1$, и для любой вершины с индексом $v$ её левый сын $-$ $2 \cdot v$, а правый сын $-$ $2 \cdot v + 1$. 
