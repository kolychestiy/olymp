# Дерево отрезков. Оно же ДО.

### Задача
Решим такую задачу. Есть массив $a_0, a_1, \ldots , a_{n-1}$ из $n$ чисел. Нужно уметь обрабатывать за быстро ( $\mathcal{O}(\log n)$ ) 2 типа запросов:

1. Даны $l$ и $r$. Найти $\Sigma_{i=l}^{r} a_i$
2. Даны $i$ и $x$. Сделать $a_i = x$

Если решать задачу без второго запроса, то можно с помощью прексных сумм отвечать за $\mathcal{O}(1)$ на первый тип запросов. Однако если бы мы захотели обрабатывать еще и обновления в массиве, то нам каждый раз пришлось бы перестраивать его за $\mathcal{O}(n)$ для обработки второго запроса. Для устранения сей несправедливости применим дерево отрезков.

### Идея

Разбить массив на множество отрезков $T$ (отрезки могут пересекаться и включать один в другой). Для каждого отрезка хранить значение суммы чисел на нём так, чтобы для ответа нужно было насуммировать значения из $\mathcal{O}(\log n)$ отрезков, а для обновления нужно было изменить значения $\mathcal{O}(\log n)$ отрезков.

Будучи умными и адекватнемы людьми, будем работать в дальнейшем не с отрезками $[l, r]$, а с полуинтервалами $[l, r)$ (правая граница не включительно). Так принято и в C++ и так действительно очень удобно решать многие задачи.
Так же для удобства будем считать что $n = 2^k$, для некоторого целого $k$.

Очевидно, что нам необходимо включить в $T$ все отрезки вида $[i, i+1)$. Отобразим их графически друг за другом.

![](segtree1.svg)

А теперь давайте включим в $T$ все отрезки вида $[i, i+2)$, $i \mod 2 = 0$.

Включим также и отрезки вида $[i, i+4)$, $i \mod 4 = 0$.

Итоговый алгоритм выбора отрезков включенных в $T$: все отрезки удовлетворяюшие требованию $[i, i+2^k)$, $i \mod 2^k = 0$.
