# Динамическое программирование (ДП). Введение

## Числа Фибоначчи

Рассмотрим такую задачу: найти $N$-е число Фибоначчи.

Числа Фибоначчи определяются так: 

$$F_0 = 0$$
$$F_1 = 1$$
$$F_n = F_{n-2} + F_{n-1}$$

Эту задачу можно решить рекурсивно:

```cpp
int fib(n) {
    if (n == 0) return 0;
    if (n == 1) return 1;
    return fib(n - 2) + fib(n - 1);
}
```

Однако это будет работать очень долго. 20-е число посчитать еще можно, а например 50-е уже будет считаться очень долго. Всё потому, что мы будем делать слишком много лишней работы. 

Легко заметить, что мы много раз будем вычислять одно и тоже значение `fib(x)`, хотя они являются неизменными, и нам достаточно вычислить его один раз, а дальше можно использовать значение вычисленное ранее. Для этого можно просто завести массив, в котором мы будем хранить уже вычисленные значения. А также, можно ещё и избавится от рекурсии, заменив её на простой цикл перебирающий $n$ в порядке увеличения. Таким образом, когда мы дошли до очередного $n$, все значения от которого оно зависит ($F_{n-1}$ и $F_{n-2}$) уже посчитаны.

```cpp
// dp[i] - i-е число Фибоначчи
vector<int> dp(N + 1); 
dp[0] = 0; 
dp[1] = 1;
for (int i = 2; i <= N; i++) {
    dp[i] = dp[i - 2] + dp[i - 1];
}
```

Таким образом, мы получаем решение задачи за $\mathcal{O}(N)$ времени.

## Что такое ДП

Это и называется динамическим программированием (или динамикой, ДП). Основная идея состоит в том, чтобы:

* свести задачу для к задаче для чисел, меньших, чем (с помощью формулы) * хранить все ответы в массиве 
* заполнить начало массива вручную (для которых формула не работает) 
* обойти массив и заполнить ответы по формуле 
* вывести ответ откуда-то из этого массива

Чтобы решить задачу по динамике вы должны ответить на 5 вопросов: 
* Что лежит в массиве? (самый важный вопрос чаще всего)
* Как инициализировать начало массива? 
* Как обходить массив? (чаще всего слева направо, но не всегда) 
* Какой формулой считать элементы массива? 
* Где в массиве лежит ответ?

Далее мы будем использовать несколько терминов:

* **Состояние** $-$ элементы массива $dp$, то есть некоторые подзадачи (более меньшие числа) исходной задачи.
* **Переход** $-$ связи между состояниями, как одно состояние вычисляется через другое. В нашем случае есть переходы вида $dp_i = dp_{i-2} + dp_{i-1}$ для $i > 1$.
* **Параметр** $-$ индексы массива $dp$. В нашем случае это номер числа Фибоначчи.
* **Значение** $-$ значение в массиве $dp$. В нашем случае это числа Фибоначчи.
* **База** $-$ состояния, значения которых известны изначально. В нашем случае это $dp_0 = 0$ и $dp_1 = 1$.

Если вы не знакомы с теорией графов, можете пропустить следующее высказывание, и сразу перейти к модульной арифметике.

В общем случае можно сказать, что если у нас есть ацикличный ориентированный граф, то его вершины можно считать состояниями ДП, а рёбра переходами между состояниями. Тогда, если вычислять значения в вершинах в порядке обратном топологической сортировки, то можно вычислить значения всех состояний, и при вычсилении очередного значения мы уже знаем значения всех состояний, в которые из нас есть переходы. На практике зачастую топологическая сортировка гарантируется циклом `for`.

## Модульная арифметика

Последовательность $F_n$ очень быстро возрастает, и потому для вычисления чисел Фибоначчи для больших $n$ нужно либо использовать длинную арифметику, что замедляет скорость работы программы и требует дополнительных усилий, либо часто в задачах просят вычислять ответ по модулю числа $MOD$ (то есть вывести остаток от деления реального ответа на число $MOD$). Просто вычислить ответ в длинной арифметике и потом взять остаток от деления никак не ускоряет вычисления. Но если ответ просят найти по модулю, то и все вычисления можно производить по модулю!

А именно, в процессе вычислений каждый раз когда складываем, умножаем или вычитаем числа, будет брать их остаток от деления на число $MOD$. Такое нельзя проделать с делением, как с ним работать будет рассмотрено позже в теме математики. Реализационно же, если нам например скажут дать ответ по модулю числа $MOD$, мы вместо `a + b` будем писать `(a + b) % MOD`, вместо `a * b` будем писать `(a * b) % MOD` и наконец, вместо `a - b` будем писать `(a - b + MOD) % MOD` (прибавлять $MOD$ нужно, из-за особенно взятия остатка от деления в `C++` у отрицательных чисел, таким образом остаток рекомендуется брать всегда от неотрицательных чисел).

Так например, задача поиска числа Фибоначчи, где ответ надо дать по модулю $10^9 + 7$, будет выглядеть следующим образом:

```cpp
// 1e9 в данном случае это ВЕЩЕСТВЕННОЕ число равное 10^9.
const int MOD = 1e9 + 7;
vector<int> dp(N + 1); 
dp[0] = 0; 
dp[1] = 1;
for (int i = 2; i <= N; i++) {
    dp[i] = (dp[i - 2] + dp[i - 1]) % MOD;
}
cout << dp[N];
```

## Задачи на ДП

ДП $-$ очень большая и широко используемая тема. Основной упор в изучении ДП идёт на разбор конкретных задач. 

К ознакомлению предлагются следующие материалы:

* [Одномерное ДП](https://wiki.algocode.ru/index.php?title=Одномерное_ДП)
* [Двумерное ДП / черепашка](https://wiki.algocode.ru/index.php?title=Двумерное_ДП_:_черепашка)
* [Задача о рюкзаке](https://wiki.algocode.ru/index.php?title=Рюкзак)
* [Восстановление ответа](https://algocode.ru/page/ekb-7-dynamic-prog/#Восстановление-ответа). Ссылка ведёт на конкретный раздел статьи, но если есть желание можно прочитать всю статью.
* [Задача "Лесенки"](https://algocode.ru/page/ekb-7-dynamic-prog/#Лесенки). Ссылка ведёт на конкретный раздел статьи, но если есть желание можно прочитать всю статью.

### Рюкзак без стоимостей. Сложная версия.

Рассмотрим решение простой версии. Изначально, у нас есть массив $dp[S + 1]$, заполненый нулями, и только $dp[0] = 1$. Далее, мы для каждого очередного предмета веса $w$ делали переходы следующего вида: $dp[i] |= dp[i - w]$, перебирая $i$ от $S$ до $w$ (чтобы при переходе в $dp[i - w]$ было старое значение $dp$, если перебирать в порядке возрастания, то получится решение без ограничений на число предметов каждого типа). Если мы представим себе массив $dp$ как одно большое число длины $S + 1$ бит, то по сути мы делаем следующую битовую операцию при добавлении очередного предмета: `dp |= dp << w`. Конечно, битовые операции на обычных числах работают за $\mathcal{O}(1)$ ещё и с малой константой. Но это справедливо если число битов не более $64$. А у нас получается огромное число, которое даже не влезает в обычные целочисленные типы данных. Для таких случаев существует такой объект как `bitset`. Он позволяет создавать битовые последовательности произвольной длины, и совершать с ними битовые операции в примерно $64$ раза быстрее, чем если бы мы побитово работали с каждым битов последовательности по отдельности. Создание выглядит как: `bitset<C> dp;`, где `C` это константа времени компиляции ($C$ заведомо больше $S$ в нашей задаче). Таким образом, решение задачи о рюкзаке без весов можно ускорить в примерно $64$ раза.

### Лесенки. Cложная версия.

Рассмотрим решение простой версии. Рекомендуется самостоятельно подумать, как можно ускорить его для сложной версии, и только если совсем не получается, читать дальше этот разбор. У нас есть $\mathcal{O}(n^2)$ состояний, и если мы научимся за $\mathcal{O}(1)$ вычислять значение каждого из них, то мы решим сложную версию задачи за $\mathcal{O}(n^2)$ времени. Для этого рассмотрим, текущий переход в ДП: `dp[n][m] = dp[n−m][1] + dp[n−m][2] + … + dp[n−m][m−1]`. Заметим, что мы хотим брать сумму значений на префиксе $dp[n-m]$. Каким образом, мы можем это делать за $\mathcal{O}(1)$ времени? Ответ: воспользуемся подходом префиксных сумм с первого занятия.

Отметим также, что эту задачу можно было сдать и решением лёгкой версии, если воспользоваться прекальком на собственном компьютере ответов для все возмжных $8000$ значений $n$, и упихивыанием их в исходный код программы, а далее ответ на задачу это просто взять число из этого массива. Мы рекомендуем пробовать это только после того, как вам удастся сдать решение работающее в реальном времени за $\mathcal{O}(n^2)$ времени.
