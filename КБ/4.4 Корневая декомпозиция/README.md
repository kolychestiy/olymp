# Корневая декомпозиция

## Введение: Философия $\sqrt{N}$
В отличие от логарифмических структур (дерево отрезков), где мы делим всё пополам, здесь мы делим данные на $\sqrt{N}$ блоков длиной по $\sqrt{N}$.
*   **Плюсы:** Проще реализовывать, чем Декартово дерево или Heavy-Light Decomposition. Работает для задач, где операции не ассоциативны (например, «количество различных чисел»). Меньшие константы.
*   **Минусы:** Асимптотика $O(\sqrt{N})$ хуже, чем $O(\log N)$. При $N=10^5$, $\sqrt{N} \approx 316$, а $\log N \approx 17$.

---

## 1. Декомпозиция на массивах (Классическая)

Применяется для запросов на отрезках (сумма, минимум, максимум), если есть обновления элементов.

### Структура
1.  Исходный массив $A$ длины $N$.
2.  Разбиваем его на блоки размером $K \approx \sqrt{N}$. Количество блоков также $\approx \sqrt{N}$.
3.  Заводим массив `b`, где `b[i]` хранит результат (сумму, минимум) для $i$-го блока целиком.

### Операции
*   **Построение ($O(N)$):** Проходим по массиву и считаем значения для каждого блока.
*   **Обновление точки ($O(1)$):**
    Если меняем $A[i]$, то обновляем и соответствующее значение `b[i/K]`.
*   **Запрос на отрезке $[L, R]$ ($O(\sqrt{N})$):**
    Отрезок разбивается на три части:
    1.  **Левый хвост:** Элементы из начального блока (от $L$ до конца блока). Перебираем вручную.
    2.  **Центральная часть:** Целые блоки, полностью попадающие в $[L, R]$. Берем готовые значения из массива `b`.
    3.  **Правый хвост:** Элементы из конечного блока (от начала блока до $R$). Перебираем вручную.

### Реализация (Сумма на отрезке)
```cpp
const int LEN = 320; // Примерно sqrt(100000)
int a[100005];
long long b[320];

void update(int idx, int val) {
    int block = idx / LEN;
    b[block] -= a[idx];
    a[idx] = val;
    b[block] += a[idx];
}

long long query(int l, int r) {
    long long sum = 0;
    int c_l = l / LEN;
    int c_r = r / LEN;

    if (c_l == c_r) { // Отрезок внутри одного блока
        for (int i = l; i <= r; ++i) sum += a[i];
    } else {
        // Левый хвост
        for (int i = l; i < (c_l + 1) * LEN; ++i) sum += a[i];
        // Целые блоки
        for (int i = c_l + 1; i < c_r; ++i) sum += b[i];
        // Правый хвост
        for (int i = c_r * LEN; i <= r; ++i) sum += a[i];
    }
    return sum;
}
```

---

## 2. Алгоритм Мо (Mo's Algorithm)

Это метод решения задач на отрезках в режиме **offline** (когда все запросы известны заранее). Позволяет решать сложные задачи, например: «количество различных элементов на отрезке», «элемент, встречающийся ровно $k$ раз».

### Идея
Мы можем пересчитать ответ для отрезка $[L, R+1]$, зная ответ для $[L, R]$, за $O(1)$ (просто добавив один элемент). Алгоритм Мо упорядочивает запросы так, чтобы суммарное перемещение границ $L$ и $R$ было минимальным.

### Сортировка запросов
Пусть $K = \sqrt{N}$.
Сортируем запросы $(L, R)$ по паре: `(L / K, R)`.
1.  Сначала по номеру блока левой границы.
2.  При равенстве блоков — по возрастанию правой границы $R$.

*(Оптимизация: для четных блоков сортировать $R$ по возрастанию, для нечетных — по убыванию. Это избавляет от холостого пробега $R$ обратно).*

### Алгоритм
1.  Храним текущие границы `currL`, `currR` и текущий `answer`. Изначально отрезок пустой.
2.  Перебираем отсортированные запросы.
3.  Пока `currL > L`: `add(--currL)`
4.  Пока `currR < R`: `add(++currR)`
5.  Пока `currL < L`: `remove(currL++)`
6.  Пока `currR > R`: `remove(currR--)`
7.  Сохраняем ответ для текущего запроса.

### Сложность
*   Правая граница $R$: внутри одного блока $L$ двигается только вправо (суммарно $N$). Всего блоков $\sqrt{N}$. Итого $O(N \sqrt{N})$.
*   Левая граница $L$: для каждого запроса сдвигается не более чем на $\sqrt{N}$. Всего $Q$ запросов. Итого $O(Q \sqrt{N})$.
*   **Итого:** $O((N+Q)\sqrt{N})$.

### Пример: Количество различных чисел
```cpp
int cnt[MAX_VAL]; // Сколько раз число встречается на текущем отрезке
int distinct_count = 0;

void add(int idx) {
    int val = a[idx];
    if (cnt[val] == 0) distinct_count++;
    cnt[val]++;
}

void remove(int idx) {
    int val = a[idx];
    cnt[val]--;
    if (cnt[val] == 0) distinct_count--;
}
```

---

## 3. Декомпозиция на запросах (Sqrt over Queries)

Используется, когда структура данных поддерживает быстрое построение (статик), но сложные обновления.

### Идея
Разбиваем $Q$ запросов на блоки по $\sqrt{Q}$.
Обрабатываем запросы блоками:
1.  Накапливаем обновления в буфер, не применяя их к основной структуре.
2.  Для ответа на запрос чтения берем данные из основной структуры и вручную проверяем, как накопленные в буфере обновления влияют на этот конкретный запрос.
3.  Когда буфер переполняется (прошло $\sqrt{Q}$ запросов), перестраиваем структуру "с нуля" с учетом всех обновлений.

### Пример применения
**Задача о динамической связности:** Добавление ребер, удаление ребер, проверка связности.
Если удалений мало или они сложные, можно каждые $\sqrt{Q}$ операций перестраивать DSU или граф заново.

---

## 4. Корневые эвристики в графах (Heavy-Light)

Применяется, когда параметры задачи зависят от степеней вершин. Вершины делятся на два типа:
1.  **Тяжелые (Heavy):** Степень вершины $\ge \sqrt{M}$ (где $M$ — число ребер).
2.  **Легкие (Light):** Степень вершины $< \sqrt{M}$.

**Свойства:**
*   Тяжелых вершин не более $2\sqrt{M}$ (так как сумма степеней $2M$).
*   У легкой вершины мало соседей (меньше $\sqrt{M}$).

### Задача: Поиск треугольников (циклов длины 3)
Нужно найти количество троек $(u, v, w)$, таких что все они соединены ребрами.

**Алгоритм:**
1.  Ориентируем ребра графа, превращая его в DAG (направленный ациклический граф), чтобы избежать дубликатов и оптимизировать перебор.
    *   Ребро $(u, v)$ направляем от $u$ к $v$, если $deg(u) < deg(v)$.
    *   Если степени равны, то от меньшего индекса к большему.
2.  Теперь у каждой вершины исходящая степень (out-degree) не превышает $\sqrt{M}$.
    *   Если $u$ легкая, то исходящих ребер мало по определению.
    *   Если $u$ тяжелая, она может иметь ребра только в более тяжелые (которых мало) или в вершины с большим индексом (что тоже ограничивает).
3.  **Перебор:**
    ```cpp
    long long triangles = 0;
    // adj - список смежности ориентированного графа
    for (int u = 0; u < n; ++u) {
        for (int v : adj[u]) {       // v - сосед u
            for (int w : adj[v]) {   // w - сосед v
                // Проверяем, есть ли ребро u -> w или w -> u (в исходном графе)
                // Для быстрого поиска можно использовать bitset, hashset 
                // или метки (visited array)
                if (is_connected(u, w)) {
                    triangles++;
                }
            }
        }
    }
    ```
    
**Сложность:** $O(M \sqrt{M})$. Каждое ребро $(u, v)$ мы проходим один раз, и внутренний цикл делает не более $O(\text{out\_degree}(v))$ итераций. А out-degree ограничено $\sqrt{M}$.

### Другие применения
*   **Обновление в вершине, запрос у соседей:**
    *   Если обновляем легкую: просто перебираем всех её соседей и меняем им значения.
    *   Если обновляем тяжелую: ставим ей "lazy" метку.
    *   При запросе значения в вершине: берем её собственное значение + сумму lazy меток от всех её *тяжелых* соседей (их перебрать быстро, так как тяжелых вершин всего $\sqrt{M}$).

---

## Резюме

| Метод | Главная идея | Сложность | Тип задач |
| :--- | :--- | :--- | :--- |
| **Декомпозиция массива** | Делим массив на блоки по $\sqrt{N}$ | $O(\sqrt{N})$ query/update | RSQ, RMQ с обновлениями |
| **Алгоритм Мо** | Сортируем запросы змейкой | $O((N+Q)\sqrt{N})$ | Сложные offline запросы на отрезках |
| **Декомпозиция запросов** | Перестройка структуры каждые $\sqrt{Q}$ шагов | Зависит от задачи | Статические структуры в динамике |
| **Графовые эвристики** | Разделение вершин по степени $\sqrt{M}$ | $O(M\sqrt{M})$ | Треугольники, клики, взаимодействие соседей |