# Алгоритмы на деревьях

Дерево — это связный граф без циклов, содержащий $N$ вершин и $N-1$ рёбер.
Основа большинства алгоритмов на деревьях — обход в глубину (**DFS**). Мы «спускаемся» до листьев, вычисляем что-то там, и «поднимаем» результаты наверх к корню.

---

## 1. ДП по поддеревьям (Tree DP)

**Суть метода:**
Ответ для вершины $v$ вычисляется на основе ответов для её детей ($to_1, to_2, \dots$).
Порядок вычислений: **снизу вверх** (Post-order traversal). Сначала рекурсивно вызываем DFS для детей, потом обрабатываем текущую вершину.

**Общая схема:**
```cpp
void dfs(int v, int p) { // v - текущая, p - родитель
    // 1. Инициализация (база динамики для листа)
    dp[v] = ...; 

    for (int to : g[v]) {
        if (to == p) continue; // Не идем обратно вверх
        
        dfs(to, v); // 2. Сначала вычисляем всё для ребенка
        
        // 3. Пересчет (Transition): обновляем ответ для v, используя ответ to
        update(dp[v], dp[to]);
    }
    
    // 4. Финальная обработка для v (если нужно)
}
```

### Пример 1: Максимальное независимое множество (МНМ)
*Задача:* Выбрать максимальное количество вершин так, чтобы никакие две выбранные вершины не были соединены ребром.

**Состояние:**
*   `dp[v][0]` — макс. кол-во вершин в поддереве $v$, если саму $v$ **не берем**.
*   `dp[v][1]` — макс. кол-во вершин в поддереве $v$, если $v$ **берем**.

**Переходы:**
1.  Если мы **берем** $v$ (`dp[v][1]`), то детей брать **нельзя**.
    $$dp[v][1] = 1 + \sum dp[to][0]$$
2.  Если мы **не берем** $v$ (`dp[v][0]`), то детей можно **либо брать, либо нет** (выбираем лучшее).
    $$dp[v][0] = \sum \max(dp[to][0], dp[to][1])$$

**Реализация:**
```cpp
int dp[MAXN][2];

void dfs(int v, int p) {
    dp[v][0] = 0;
    dp[v][1] = 1; // Берем саму вершину v
    
    for (int to : g[v]) {
        if (to == p) continue;
        dfs(to, v);
        
        dp[v][1] += dp[to][0];
        dp[v][0] += max(dp[to][0], dp[to][1]);
    }
}
// Ответ: max(dp[root][0], dp[root][1])
```

### Другие типовые задачи на Tree DP:
1.  **Размер поддерева:** `sz[v] = 1 + sum(sz[to])`.
2.  **Диаметр дерева:** Максимальное расстояние между двумя вершинами. Для каждой вершины ищем два самых длинных пути, уходящих вниз в разные поддеревья.
3.  **Рюкзак на дереве (Tree Knapsack):** Сложнее. Нужно выбрать $K$ вершин в поддереве с макс. весом. Обычно это свертка массивов (как перемножение полиномов).
    *   *Сложность:* Кажется $O(N^2)$, но при правильной реализации (размер поддерева ограничивает цикл) — $O(N^2)$ всего.

---

## 2. Сливаемые множества (Small-to-Large Merging)

**Проблема:**
Нужно для каждой вершины $v$ быстро отвечать на запросы касательно **содержимого** её поддерева.
*Пример:* Посчитать количество *различных* чисел (цветов) в поддереве каждой вершины.

**Наивное решение ($O(N^2)$):**
Для каждой вершины создаем `std::set`, копируем туда все элементы из `set`-ов детей. Это слишком медленно, так как один элемент может копироваться $N$ раз (в линию).

**Оптимизация (Small-to-Large):**
Идея: **Всегда перекладывать элементы из меньшего множества в большее.**
Если у вершины $v$ самый большой ребенок (heavy child) имеет множество размера 1000, а второй ребенок — размера 5, мы не копируем 1000 элементов. Мы берем множество большого ребенка как основу для $v$, и добавляем туда 5 элементов малого.

### Алгоритмическая сложность
Каждый элемент перемещается из одного множества в другое только тогда, когда он попадает в множество, которое как минимум **в 2 раза больше** текущего.
Следовательно, каждый элемент будет скопирован не более $O(\log N)$ раз.
Если используем `std::set`, общая сложность: **$O(N \log^2 N)$**.
Если используем `vector` (сортировка + merge) или хеш-таблицы: **$O(N \log N)$**.

### Реализация (Задача о разных цветах)

Используем `std::set<int>`. Ключевой трюк — использование функции `swap`, которая меняет местами содержимое контейнеров за $O(1)$.

```cpp
int col[MAXN]; // цвета вершин
set<int>* st[MAXN]; // Указатели на сеты, чтобы делать swap
int ans[MAXN]; // Ответы для вершин

void dfs(int v, int p) {
    // 1. Создаем множество для текущей вершины (пока только она сама)
    st[v] = new set<int>();
    st[v]->insert(col[v]);

    for (int to : g[v]) {
        if (to == p) continue;
        
        dfs(to, v); // Рекурсивно решаем для детей
        
        // Магия Small-to-Large
        // Сравниваем размер текущего множества и множества ребенка
        if (st[v]->size() < st[to]->size()) {
            // Если у ребенка множество больше, меняемся с ним местами (за O(1))
            swap(st[v], st[to]); 
        }
        
        // Теперь st[v] — большое, st[to] — маленькое.
        // Перекладываем элементы из маленького в большое.
        for (int x : *st[to]) {
            st[v]->insert(x);
        }
        
        // Очищаем память (опционально, но полезно)
        delete st[to]; 
    }
    
    // Сохраняем ответ для текущей вершины
    ans[v] = st[v]->size();
}
```

### Альтернатива: DSU on Trees (Sack)
Существует похожий метод, называемый **DSU on Trees** (или Sack), который делает то же самое без явных указателей, используя один глобальный массив и `dfs`.
*   **Плюс:** Меньше оверхеда по памяти, часто быстрее.
*   **Минус:** Чуть сложнее в понимании.
*   **Small-to-Large с `std::set`** — более универсальный и простой в написании метод, когда время $O(N \log^2 N)$ проходит.

### Когда применять Small-to-Large?
1.  Запросы вида «количество различных элементов в поддереве».
2.  Запросы вида «какой элемент встречается чаще всего в поддереве» (можно мерджить `map<int, int>`).
3.  Любые задачи, где нужно объединять структуры данных при подъеме из рекурсии, и операция объединения зависит от размера меньшей структуры.

---

## Сводка

| Метод | Что делает | Сложность | Типичная задача |
| :--- | :--- | :--- | :--- |
| **Tree DP** | Вычисляет число/состояние на основе чисел детей | $O(N)$ | Макс. независимое множество, диаметр, размер поддерева |
| **Small-to-Large** | Объединяет множества (`set`, `map`) детей в родителя | $O(N \log^2 N)$ | Число различных цветов в поддереве |
| **Tree Knapsack** | (Разновидность DP) Выбирает $K$ предметов в поддереве | $O(N^2)$ | Выбрать $K$ черных вершин с мин. суммой весов |