# Дерево отрезков: Продвинутые техники

## 1. Обновление на отрезке (Mass Update / Lazy Propagation)

В базовом дереве отрезков (ДО) операция изменения элемента занимает $O(\log N)$, но если нужно изменить все элементы на отрезке $[L, R]$ (например, прибавить $X$), последовательный вызов обновления даст $O(N \log N)$, что слишком медленно. Техника **отложенных операций (Lazy Propagation)** позволяет делать это за $O(\log N)$.

### Основная идея
Мы не обновляем все листья сразу. Вместо этого мы обновляем текущую вершину и помечаем её «обещанием» (lazy tag) о том, что нужно протолкнуть изменение детям, когда (и только если) мы в них спустимся.

### Структура
Помимо массива `tree[]` (где хранятся значения, например, сумма), нам нужен массив `lazy[]` того же размера.
*   `lazy[v]`: хранит значение, которое нужно прибавить ко всем элементам в поддереве вершины $v$.

### Функция `push` (Проталкивание)
Это ключевая функция. Она вызывается в начале обработки любой вершины (и в `update`, и в `query`), чтобы передать накопленный «долг» детям.

```cpp
long long tree[4 * MAXN];
long long lazy[4 * MAXN]; // Изначально 0

// Функция проталкивания
void push(int v, int tl, int tr) {
    if (lazy[v] != 0) {
        int tm = (tl + tr) / 2;
        
        // 1. Применяем lazy к детям (обновляем их значения)
        // Если операция - сумма, то прибавляем lazy * длину_отрезка
        tree[2*v] += lazy[v] * (tm - tl + 1);
        tree[2*v+1] += lazy[v] * (tr - tm);
        
        // 2. Передаем lazy детям (накапливаем)
        lazy[2*v] += lazy[v];
        lazy[2*v+1] += lazy[v];
        
        // 3. Обнуляем lazy у текущей вершины
        lazy[v] = 0;
    }
}
```

### Обновление на отрезке (`update`)
```cpp
void update(int v, int tl, int tr, int l, int r, int add) {
    if (l > r) return;
    
    // Если текущий отрезок полностью внутри [l, r]
    if (l == tl && r == tr) {
        tree[v] += (long long)add * (tr - tl + 1);
        lazy[v] += add; // Запоминаем, что нужно передать детям
    } else {
        push(v, tl, tr); // ВАЖНО: сначала проталкиваем старые изменения
        int tm = (tl + tr) / 2;
        update(2*v, tl, tm, l, min(r, tm), add);
        update(2*v+1, tm+1, tr, max(l, tm+1), r, add);
        tree[v] = tree[2*v] + tree[2*v+1]; // Пересчитываем текущую вершину
    }
}
```

### Запрос (`query`)
```cpp
long long query(int v, int tl, int tr, int l, int r) {
    if (l > r) return 0;
    if (l == tl && r == tr) return tree[v];
    
    push(v, tl, tr); // ВАЖНО: проталкиваем перед спуском
    int tm = (tl + tr) / 2;
    return query(2*v, tl, tm, l, min(r, tm)) +
           query(2*v+1, tm+1, tr, max(l, tm+1), r);
}
```

**Важные нюансы:**
1.  **Присваивание на отрезке:** Если операция — «присвоить всем $X$», то `lazy` переписывается (а не суммируется), и нужен специальный флаг (например, -1), показывающий, что отложенной операции нет.
2.  **Порядок операций:** Если есть и прибавление, и присваивание, важен порядок проталкивания (обычно присваивание обнуляет предыдущие прибавления).

---

## 2. Неявное дерево отрезков (Implicit / Dynamic Segment Tree)

Обычное ДО требует массив размера $4N$. Что делать, если координаты достигают $10^9$ или $10^{18}$, а количество запросов $Q$ небольшое ($10^5$)? Создать массив нельзя.

### Решение
Мы создаем вершины дерева только тогда, когда они реально нужны (когда мы в них заходим).
*   Изначально есть только корень, отвечающий за отрезок $[0, 10^9]$.
*   Вершины хранятся не в массиве с индексацией $2v, 2v+1$, а как объекты (структуры) с указателями на левого и правого сына.

### Реализация (на указателях)
```cpp
struct Node {
    long long sum;
    Node *left, *right;
    
    Node() : sum(0), left(nullptr), right(nullptr) {}
};

// Функция для обновления (добавляет val в позицию pos)
void update(Node* v, long long tl, long long tr, int pos, int val) {
    if (tl == tr) {
        v->sum += val;
        return;
    }
    long long tm = (tl + tr) / 2;
    
    if (pos <= tm) {
        if (!v->left) v->left = new Node(); // Создаем динамически
        update(v->left, tl, tm, pos, val);
    } else {
        if (!v->right) v->right = new Node(); // Создаем динамически
        update(v->right, tm + 1, tr, pos, val);
    }
    
    // Пересчет суммы (учитываем, что детей может не быть)
    long long sum_left = v->left ? v->left->sum : 0;
    long long sum_right = v->right ? v->right->sum : 0;
    v->sum = sum_left + sum_right;
}

// Запрос суммы на [l, r]
long long query(Node* v, long long tl, long long tr, int l, int r) {
    if (!v || l > r) return 0; // Если вершины нет, сумма там 0
    if (l == tl && r == tr) return v->sum;
    
    long long tm = (tl + tr) / 2;
    return query(v->left, tl, tm, l, min((long long)r, tm)) +
           query(v->right, tm + 1, tr, max((long long)l, tm + 1), r);
}
```

### Характеристики
*   **Память:** $O(Q \log C)$, где $C$ — диапазон координат. На каждый запрос создается $\log C$ вершин.
*   **Время:** $O(Q \log C)$.
*   **Альтернатива:** Сжатие координат (Coordinate Compression), если все запросы известны заранее (offline). Неявное ДО работает в онлайне.

---

## 3. Персистентное дерево отрезков (Persistent Segment Tree)

Персистентность означает, что после изменения структуры данных старая версия остается доступной. Мы можем делать запросы к любой версии дерева.

### Идея (Path Copying)
При изменении значения в точке мы не меняем старую вершину. Мы создаем **новую** вершину.
*   Новая вершина копирует связи старой.
*   Путь от корня до листа меняется $\to$ мы создаем копии всех вершин на этом пути ($\log N$ штук).
*   Остальные поддеревья (которые не затронуты) переиспользуются по ссылке.

В итоге у нас есть массив корней `roots[version]`, где каждый корень ведет в свое дерево.

### Реализация (на массивах для скорости)
На олимпиадах лучше использовать статический массив структур вместо `new Node()`, это быстрее и экономит память.

```cpp
struct Node {
    int left, right; // Индексы детей в массиве nodes
    int sum;
} nodes[MAXN * 20]; // log N вершин на запрос

int roots[MAXN]; // Корни версий
int sz = 1; // Счетчик созданных вершин

// Построение начального дерева (версия 0)
int build(int tl, int tr) {
    int v = sz++; // Новая вершина
    if (tl == tr) return v;
    int tm = (tl + tr) / 2;
    nodes[v].left = build(tl, tm);
    nodes[v].right = build(tm + 1, tr);
    return v;
}

// Обновление: возвращает индекс НОВОЙ вершины
int update(int v_old, int tl, int tr, int pos, int val) {
    int v_new = sz++; // Создаем копию
    nodes[v_new] = nodes[v_old]; // Копируем данные (в т.ч. ссылки на детей)
    
    if (tl == tr) {
        nodes[v_new].sum += val;
        return v_new;
    }
    
    int tm = (tl + tr) / 2;
    if (pos <= tm) {
        // Меняем левого ребенка на обновленную версию, правый остается старым
        nodes[v_new].left = update(nodes[v_old].left, tl, tm, pos, val);
    } else {
        nodes[v_new].right = update(nodes[v_old].right, tm + 1, tr, pos, val);
    }
    
    nodes[v_new].sum = nodes[nodes[v_new].left].sum + nodes[nodes[v_new].right].sum;
    return v_new;
}
```

### Классическая задача: K-я порядковая статистика на отрезке
Дано массив $A$. Запросы $(L, R, K)$: найти $K$-е по величине число на подмассиве $A[L \dots R]$.

**Решение:**
1.  Строим персистентное ДО над **диапазоном значений** чисел (не индексов массива!).
2.  Версия $i$ дерева содержит значения $A[0 \dots i]$. То есть, мы по очереди добавляем числа $A[i]$ в дерево значений.
3.  Чтобы найти информацию об отрезке индексов $[L, R]$, мы используем свойство префиксных сумм:
    `count(root[R]) - count(root[L-1])` показывает, сколько чисел попало в определенный диапазон значений на отрезке индексов $[L, R]$.
4.  Спускаемся по дереву: если слева лежит $\ge K$ чисел, идем налево. Иначе вычитаем кол-во слева из $K$ и идем направо.

```cpp
// Поиск K-го числа
int find_kth(int v_L, int v_R, int tl, int tr, int k) {
    if (tl == tr) return tl; // Нашли значение
    
    int tm = (tl + tr) / 2;
    // Сколько чисел в левом поддереве именно на отрезке [L, R] исходного массива
    int count_left = nodes[nodes[v_R].left].sum - nodes[nodes[v_L].left].sum;
    
    if (count_left >= k) {
        return find_kth(nodes[v_L].left, nodes[v_R].left, tl, tm, k);
    } else {
        return find_kth(nodes[v_L].right, nodes[v_R].right, tm + 1, tr, k - count_left);
    }
}
```

---

## Резюме по теме

| Техника | Для чего нужна | Сложность | Ключевая особенность |
| :--- | :--- | :--- | :--- |
| **Lazy Propagation** | Обновление значений на отрезке $[L, R]$ | $O(\log N)$ | Массив `lazy`, функция `push`. |
| **Implicit SegTree** | Огромные координаты ($10^9$), мало запросов | $O(Q \log C)$ | Динамическое создание вершин, указатели. |
| **Persistent SegTree** | Доступ к истории, 2D задачи (static rectangle) | $O(\log N)$ Space & Time | Копирование пути при обновлении, массив корней. |

### Полезные советы для олимпиады:
1.  **Lazy:** Не забывайте вызывать `push` **перед** тем, как смотреть на детей или идти в них. Ошибка "забыл push" — самая частая.
2.  **Implicit:** Если есть возможность сжать координаты, лучше сжать и использовать обычное ДО (меньше константа, меньше багов с памятью). Используйте неявное ДО, если запросы идут в онлайне и координаты нельзя сжать заранее.
3.  **Persistence:** Требует много памяти. Для $2 \cdot 10^5$ запросов нужно около $4 \dots 5 \cdot 10^6$ вершин. Всегда считайте память: `sizeof(Node) * MAX_NODES / 1024 / 1024` МБ.