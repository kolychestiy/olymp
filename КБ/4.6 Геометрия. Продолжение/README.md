# Геометрия: Многоугольники

## 0. Базовый инструментарий
Для работы с многоугольниками необходимо определить структуру точки и функцию векторного (косого) произведения.

```cpp
struct Point {
    long long x, y;
    Point operator-(const Point& other) const {
        return {x - other.x, y - other.y};
    }
};

// Косое произведение (Cross Product) векторов a и b
// > 0, если b слева от a (поворот против часовой)
// < 0, если b справа от a (поворот по часовой)
// = 0, если вектора коллинеарны
long long cross_product(Point a, Point b) {
    return a.x * b.y - a.y * b.x;
}
```

---

## 1. Многоугольники (Основные понятия)

**Многоугольник** в программировании обычно задается массивом точек `vector<Point>` в порядке обхода (чаще всего **против часовой стрелки — CCW**).

*   **Простой многоугольник:** Граница не пересекает сама себя.
*   **Выпуклый многоугольник (Convex):**
    *   Все внутренние углы меньше 180°.
    *   Отрезок, соединяющий любые две точки внутри многоугольника, полностью лежит внутри него.
    *   *Свойство:* При обходе контура мы всегда поворачиваем в одну сторону (все векторные произведения соседних сторон имеют один знак).

---

## 2. Площадь многоугольника

Для вычисления площади любого *простого* многоугольника (как выпуклого, так и нет) используется **Формула шнурков** (Shoelace formula) или метод трапеций.

### Формула
Площадь $S$ многоугольника с вершинами $(x_1, y_1), \dots, (x_n, y_n)$ равна:
$$ 2S = \left| \sum_{i=1}^{n} (x_i y_{i+1} - x_{i+1} y_i) \right| $$
где $(x_{n+1}, y_{n+1}) = (x_1, y_1)$.

В терминах векторного произведения это сумма косых произведений радиус-векторов соседних вершин:
$$ 2S = \left| \sum_{i=1}^{n} (P_i \times P_{i+1}) \right| $$

### Особенности реализации
1.  **Знаковая площадь:** Если убрать модуль, формула вернет *ориентированную площадь*.
    *   $S > 0$: обход против часовой стрелки.
    *   $S < 0$: обход по часовой стрелке.
2.  **Целочисленность:** Во избежание потери точности все вычисления лучше проводить в `long long` (умножив результат на 2), а деление на 2 выполнять только при выводе ответа (или выводить как `.5`).
3.  **Теорема Пика** (для многоугольников на целочисленной решетке):
    $$ S = I + \frac{B}{2} - 1 $$
    *   $S$ — площадь.
    *   $I$ — количество целочисленных точек строго внутри.
    *   $B$ — количество целочисленных точек на границе (можно найти через $\gcd(|x_1-x_2|, |y_1-y_2|)$ для каждой стороны).

```cpp
long long polygon_area_2(const vector<Point>& p) {
    long long area = 0;
    for (size_t i = 0; i < p.size(); ++i) {
        Point p1 = p[i];
        Point p2 = p[(i + 1) % p.size()]; // Замыкание на начало
        area += cross_product(p1, p2);
    }
    return abs(area); // Возвращаем удвоенную площадь
}
```

---

## 3. Выпуклая оболочка (Convex Hull)

**Задача:** Найти минимальный выпуклый многоугольник, содержащий все заданные точки множества. (Аналогия: натянуть резинку на гвоздики).

### Алгоритм Эндрю (Monotone Chain)
Это стандартный алгоритм для олимпиад. Он строит верхнюю и нижнюю цепочки оболочки отдельно.
*   **Сложность:** $O(N \log N)$ (из-за сортировки).

**Шаги:**
1.  Сортируем точки: сначала по координате $X$, при равенстве — по $Y$.
2.  Удаляем дубликаты (опционально).
3.  **Верхняя оболочка:** Проходим по точкам, добавляем их в стек. Если последние три точки в стеке образуют "левый поворот" (или прямой), значит, мы нарушаем выпуклость — удаляем среднюю точку, пока поворот не станет "правым".
4.  **Нижняя оболочка:** Аналогично, но проходим по точкам в обратном порядке.

```cpp
// Возвращает точки выпуклой оболочки в порядке CCW (против часовой)
vector<Point> convex_hull(vector<Point> pts) {
    int n = pts.size();
    if (n <= 2) return pts;
    
    // 1. Сортировка
    sort(pts.begin(), pts.end(), [](Point a, Point b) {
        return a.x < b.x || (a.x == b.x && a.y < b.y);
    });

    vector<Point> h; // Стек для оболочки

    // 2. Нижняя часть (обход слева направо)
    for (int i = 0; i < n; ++i) {
        // Пока последние 3 точки образуют поворот НЕ направо (или коллинеарны) -> удаляем
        // cross_product <= 0 для строго выпуклой (без точек на сторонах)
        // cross_product < 0, если нужны точки на сторонах
        while (h.size() >= 2) {
            Point p_new = pts[i];
            Point p_last = h.back();
            Point p_prev = h[h.size() - 2];
            if (cross_product(p_new - p_last, p_last - p_prev) <= 0) { // Важный момент: направление векторов
                 // Правильнее: вектор (p_last - p_prev) и (p_new - p_last)
                 // cross_product(b-a, c-b). Если > 0 - поворот влево (ОК для CCW)
                 // Но здесь мы строим оболочку, проверяем "выпуклость".
                 // Для нижней цепи поворот должен быть влево (CCW). Если вправо или прямо - удаляем?
                 // Упрощение: используем cross_product(last - prev, current - last)
                 // Если <= 0 (поворот вправо или прямо), удаляем last.
                 h.pop_back();
            } else {
                break;
            }
        }
        h.push_back(pts[i]);
    }

    // 3. Верхняя часть (обход справа налево)
    int lower_size = h.size();
    for (int i = n - 2; i >= 0; --i) {
        while (h.size() > lower_size) { // > lower_size чтобы не удалить начало нижней части
            Point p_curr = pts[i];
            Point p_last = h.back();
            Point p_prev = h[h.size() - 2];
            if (cross_product(p_last - p_prev, p_curr - p_last) <= 0) {
                h.pop_back();
            } else {
                break;
            }
        }
        h.push_back(pts[i]);
    }

    h.pop_back(); // Удаляем дубликат начальной точки (она добавилась второй раз)
    return h;
}
```
*Примечание:* В коде выше логика `cross_product` проверяет "левый поворот". Если поворот правый или прямой (`<= 0`), точка удаляется, так как она делает оболочку вогнутой.

### Другие алгоритмы
*   **Грэхем (Graham Scan):** Сортировка по полярному углу. Сложнее в реализации.
*   **Джарвис (Jarvis March):** Заворачивание подарка. $O(N \cdot H)$, где $H$ — число точек в оболочке. Хорош, если оболочка маленькая, но квадратичен в худшем случае.

---

## 4. Принадлежность точки многоугольнику

### Случай А: Выпуклый многоугольник ($O(\log N)$)
Если многоугольник выпуклый, можно использовать бинарный поиск (метод клиньев).
1.  Выбираем 0-ю вершину как центр веера.
2.  Проверяем, лежит ли точка внутри угла $(P_1, P_0, P_{n-1})$.
3.  Бинарным поиском находим такой сектор $(P_0, P_i, P_{i+1})$, в котором лежит точка (по полярному углу).
4.  Проверяем, лежит ли точка справа от вектора $P_i \to P_{i+1}$ (через векторное произведение). Если да (для CCW) — точка внутри.

### Случай Б: Произвольный многоугольник ($O(N)$)
Универсальный метод: **Ray Casting (Метод луча)**.

**Суть:**
1.  Выпускаем луч из проверяемой точки в произвольном направлении (обычно горизонтально вправо: $y = const, x > x_{pt}$).
2.  Считаем количество пересечений луча со сторонами многоугольника.
3.  Если количество пересечений **нечетное** — точка **внутри**.
4.  Если **четное** — точка **снаружи**.

**Сложные случаи (Corner cases):**
*   Точка лежит на границе (проверяется отдельно).
*   Луч проходит через вершину многоугольника.
*   Луч совпадает со стороной многоугольника.

**Правильная реализация луча:**
Чтобы избежать проблем с вершинами, используем правило:
Пересечение засчитывается, если один конец ребра строго выше луча, а другой — не строго ниже (или наоборот). То есть мы представляем, что луч проходит чуть-чуть выше $y$-координаты точки.

```cpp
// 0 - снаружи, 1 - внутри, -1 - на границе (опционально)
bool is_point_in_polygon(const vector<Point>& poly, Point p) {
    bool inside = false;
    int n = poly.size();
    for (int i = 0; i < n; ++i) {
        Point p1 = poly[i];
        Point p2 = poly[(i + 1) % n];
        
        // Проверка на принадлежность границе (через косое произведение и скалярное)
        // if (on_segment(p1, p2, p)) return true; // Реализовать при необходимости

        // Алгоритм луча (вправо)
        // Проверяем, что ребро пересекает горизонтальную прямую y = p.y
        // Условие (p1.y > p.y) != (p2.y > p.y) гарантирует, что точки по разные стороны
        if ((p1.y > p.y) != (p2.y > p.y)) {
            // Вычисляем x-координату пересечения ребра с прямой y = p.y
            // Пропорция: (x - x1) / (x2 - x1) = (p.y - y1) / (y2 - y1)
            // x = x1 + (x2 - x1) * (p.y - y1) / (y2 - y1)
            // Нам нужно, чтобы точка пересечения была правее p.x
            
            // Используем умножение, чтобы избежать деления и float:
            // (p2.x - p1.x) * (p.y - p1.y) / (p2.y - p1.y) + p1.x > p.x
            // Приводим к общему знаменателю и следим за знаком (p2.y - p1.y)
            
            long long cross = (p2.x - p1.x) * (long long)(p.y - p1.y) - 
                              (p2.y - p1.y) * (long long)(p.x - p1.x);
            
            // Правило знаков зависит от направления ребра (вверх или вниз)
            if (p2.y > p1.y) {
                if (cross > 0) inside = !inside;
            } else {
                if (cross < 0) inside = !inside;
            }
        }
    }
    return inside;
}
```

---

## 5. Полезные советы для олимпиад
1.  **Избегайте `double`:** Почти все задачи вычислительной геометрии на олимпиадах можно решить в целых числах (`long long`), если координаты целые. `double` используйте только в крайнем случае (корни, углы, точные расстояния).
2.  **`EPS` (Epsilon):** Если используете `double`, сравнивайте числа с погрешностью: `if (abs(a - b) < 1e-9)`.
3.  **Векторное произведение — это всё:** Оно определяет площадь, относительное положение (слева/справа), пересечение отрезков и выпуклость. Выучите его наизусть.
4.  **Коллинеарные точки:** В задачах на выпуклую оболочку внимательно читайте условие. Нужно ли включать точки, лежащие на одной прямой на границе оболочки? От этого зависит знак (`<` или `<=`) в алгоритме.