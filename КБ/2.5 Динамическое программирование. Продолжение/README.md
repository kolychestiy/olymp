# Динамическое программирование. Продолжение

## 1. Наибольшая общая подпоследовательность (НОП / LCS)

**Определение:**
Даны две последовательности $A$ (длины $N$) и $B$ (длины $M$). **Подпоследовательность** — это набор элементов, взятых из исходной последовательности в том же порядке, но не обязательно идущих подряд.
**Задача:** Найти длину самой длинной последовательности, которая является подпоследовательностью и для $A$, и для $B$.

### Рекуррентная формула
Пусть `dp[i][j]` — длина НОП для префиксов $A[0 \dots i-1]$ и $B[0 \dots j-1]$.

1.  **База:** `dp[0][0] = dp[i][0] = dp[0][j] = 0` (если одна из строк пуста, общих элементов нет).
2.  **Переход:**
    *   Если элементы совпадают ($A[i-1] == B[j-1]$):
        $$dp[i][j] = dp[i-1][j-1] + 1$$
        *(Берем этот элемент в ответ и смотрим предыдущие)*
    *   Если элементы не совпадают:
        $$dp[i][j] = \max(dp[i-1][j], \ dp[i][j-1])$$
        *(Пропускаем либо символ из A, либо из B)*

### Реализация ($O(N \cdot M)$)
```cpp
// A и B - строки или векторы, индексация с 0
// dp размера (N+1) x (M+1)

for (int i = 1; i <= n; i++) {
    for (int j = 1; j <= m; j++) {
        if (a[i-1] == b[j-1]) {
            dp[i][j] = dp[i-1][j-1] + 1;
        } else {
            dp[i][j] = max(dp[i-1][j], dp[i][j-1]);
        }
    }
}
cout << dp[n][m];
```

### Восстановление ответа
Чтобы вывести саму подпоследовательность, идем от `dp[n][m]` к `dp[0][0]`:
1.  Если $A[i-1] == B[j-1]$, то этот символ входит в НОП. Добавляем его в ответ, переходим в $(i-1, j-1)$.
2.  Иначе переходим в ту клетку, откуда пришел максимум ($(i-1, j)$ или $(i, j-1)$).
3.  В конце полученную строку нужно развернуть (`reverse`).

---

## 2. Наибольшая возрастающая подпоследовательность (НВП / LIS)

**Определение:**
Дана последовательность чисел. Нужно найти длину самой длинной подпоследовательности, элементы которой строго возрастают.

### Способ 1: Классическое ДП ($O(N^2)$)
Подходит для $N \le 5000$.

`dp[i]` — длина НВП, которая **заканчивается** элементом $A[i]$.
$$dp[i] = 1 + \max(\{dp[j] \mid j < i, A[j] < A[i]\} \cup \{0\})$$

```cpp
for (int i = 0; i < n; i++) {
    dp[i] = 1; // Сам элемент
    for (int j = 0; j < i; j++) {
        if (a[j] < a[i]) {
            dp[i] = max(dp[i], dp[j] + 1);
        }
    }
}
// Ответ: max элемент во всем массиве dp
```

### Способ 2: ДП с бинарным поиском ($O(N \log N)$)
Стандарт для олимпиад при $N \le 10^5$.

Идея: поддерживаем массив `tail`, где `tail[k]` — это **минимальное** число, на которое может заканчиваться возрастающая подпоследовательность длины `k+1`.
Массив `tail` всегда будет отсортирован, что позволяет использовать бинарный поиск.

**Алгоритм:**
1.  Проходим по всем числам $x$ исходного массива.
2.  Ищем в `tail` первое число, которое $\ge x$ (используем `lower_bound`).
3.  Если такое число нашли — заменяем его на $x$ (мы нашли более оптимальный конец для подпоследовательности той же длины).
4.  Если не нашли (все числа в `tail` меньше $x$) — дописываем $x$ в конец `tail` (увеличили длину НВП).

**Реализация:**
```cpp
vector<int> tail; // Хранит "лучшие" концы

for (int x : a) {
    auto it = lower_bound(tail.begin(), tail.end(), x);
    if (it == tail.end()) {
        tail.push_back(x);
    } else {
        *it = x;
    }
}
// Ответ: длина массива tail
cout << tail.size();
```
*Важно:* Массив `tail` НЕ содержит саму НВП, он содержит оптимальные концы. Его длина равна длине НВП.

---

## 3. Расстояние Левенштейна (Редакционное расстояние)

**Определение:**
Минимальное количество операций (вставка, удаление, замена символа), необходимое для превращения одной строки в другую.

### Рекуррентная формула
Пусть `dp[i][j]` — расстояние между префиксами $S1[0 \dots i-1]$ и $S2[0 \dots j-1]$.

1.  **База:**
    *   `dp[i][0] = i` (превратить префикс длины $i$ в пустую строку — $i$ удалений).
    *   `dp[0][j] = j` (превратить пустую строку в префикс длины $j$ — $j$ вставок).

2.  **Переход:**
    Для вычисления `dp[i][j]` рассматриваем последние символы $S1[i-1]$ и $S2[j-1]$.
    Мы можем получить состояние $(i, j)$ из трех соседних:
    *   `dp[i-1][j] + 1` (Удаление из S1).
    *   `dp[i][j-1] + 1` (Вставка в S1).
    *   `dp[i-1][j-1] + cost` (Замена/Совпадение),
        где `cost = 0`, если символы равны, и `cost = 1`, если отличаются.

    $$dp[i][j] = \min(dp[i-1][j] + 1, \ dp[i][j-1] + 1, \ dp[i-1][j-1] + (S1[i-1] \neq S2[j-1]))$$

### Реализация ($O(N \cdot M)$)

```cpp
string s1, s2; 
cin >> s1 >> s2;
int n = s1.length(), m = s2.length();

// Используем vector для динамического размера
vector<vector<int>> dp(n + 1, vector<int>(m + 1));

// Инициализация базы
for (int i = 0; i <= n; i++) dp[i][0] = i;
for (int j = 0; j <= m; j++) dp[0][j] = j;

// Основной цикл
for (int i = 1; i <= n; i++) {
    for (int j = 1; j <= m; j++) {
        int cost = (s1[i-1] == s2[j-1]) ? 0 : 1;
        dp[i][j] = min({ 
            dp[i-1][j] + 1,       // Удаление
            dp[i][j-1] + 1,       // Вставка
            dp[i-1][j-1] + cost   // Замена/Совпадение
        });
    }
}

cout << dp[n][m];
```

### Оптимизация памяти
Так как для вычисления строки $i$ нужна только строка $i-1$, можно хранить только два вектора (текущий и предыдущий). Это снижает потребление памяти с $O(NM)$ до $O(\min(N, M))$.

---

## Сводная таблица сложности

| Задача | Сложность (Время) | Сложность (Память) | Особенности |
| :--- | :--- | :--- | :--- |
| **НОП (LCS)** | $O(N \cdot M)$ | $O(N \cdot M)$ (или $O(N)$) | Ищет общие элементы с сохранением порядка. |
| **НВП (LIS)** | $O(N \log N)$ | $O(N)$ | Использует бинарный поиск (`lower_bound`). |
| **Левенштейн**| $O(N \cdot M)$ | $O(N \cdot M)$ (или $O(N)$) | Классика редактирования строк (diff, автокоррекция). |