# Паросочетания в двудольных графах

## 1. Основные определения

### Двудольный граф
Граф $G = (V, E)$ называется **двудольным**, если его множество вершин $V$ можно разбить на два непересекающихся множества (доли) $L$ (левая) и $R$ (правая) так, что все ребра графа соединяют вершины из разных долей. Внутри одной доли ребер нет.

### Паросочетание
**Паросочетание** $M$ — это набор ребер графа, в котором никакие два ребра не имеют общей вершины.
*   Если вершина $v$ является концом ребра из $M$, говорят, что она **насыщена** (covered).
*   Иначе вершина **свободна** (exposed).

### Виды паросочетаний
1.  **Максимальное паросочетание (Maximum Matching):** Паросочетание, содержащее максимально возможное количество ребер для данного графа. Именно его мы обычно ищем в задачах.
2.  **Совершенное паросочетание (Perfect Matching):** Паросочетание, которое насыщает *все* вершины графа. (Возможно только если $|L| = |R|$).

---

## 2. Теоретическая основа: Чередующиеся цепи

Для поиска максимального паросочетания используется понятие чередующихся путей.

1.  **Чередующаяся цепь (Alternating path):** Путь, в котором ребра поочередно принадлежат паросочетанию $M$ и не принадлежат ему.
2.  **Увеличивающая цепь (Augmenting path):** Это чередующаяся цепь, которая **начинается** в свободной вершине и **заканчивается** в свободной вершине.

**Лемма Бержа:** Паросочетание $M$ является максимальным тогда и только тогда, когда в графе не существует увеличивающих цепей относительно $M$.

**Суть алгоритма:** Если мы найдем увеличивающую цепь, мы можем «инвертировать» ребра вдоль неё (ребра из $M$ убрать, ребра не из $M$ добавить). Так как цепь начиналась и кончалась свободными вершинами, количество ребер в паросочетании увеличится ровно на 1.

---

## 3. Алгоритм Куна

Алгоритм Куна находит максимальное паросочетание в двудольном графе, последовательно пытаясь найти увеличивающую цепь для каждой вершины левой доли.

### Схема работы
1.  Изначально паросочетание пустое.
2.  Перебираем все вершины $v$ из левой доли ($L$).
3.  Для каждой $v$ запускаем обход (обычно DFS), пытаясь найти увеличивающую цепь, начинающуюся в $v$.
4.  Чтобы не зациклиться, поддерживаем массив `used` (посещенные вершины правой доли) для *текущего* запуска DFS.
5.  Если цепь найдена, обновляем текущее паросочетание и увеличиваем счетчик.

### Реализация (C++)

Пусть $n$ — число вершин в левой доле, $k$ — в правой.
Граф храним в виде списка смежности `g[n]`, где для каждой левой вершины указаны ее соседи справа.

Массив `mt[k]` хранит для каждой правой вершины индекс левой вершины, с которой она соединена (или -1, если свободна).

```cpp
#include <vector>
#include <iostream>
#include <cstring>

using namespace std;

const int MAXN = 1000; // Макс. число вершин в левой доле
vector<int> g[MAXN];   // Списки смежности (только ребра из L в R)
int mt[MAXN];          // С кем соединена вершина из ПРАВОЙ доли
bool used[MAXN];       // used для вершин ПРАВОЙ доли

// Функция возвращает true, если удалось найти увеличивающую цепь
bool try_kuhn(int v) {
    if (used[v]) return false; // Уже были здесь в этом запуске
    used[v] = true;

    for (int to : g[v]) {
        // Если вершина 'to' (справа) свободна
        // ИЛИ если мы можем найти увеличивающую цепь для того, кто её сейчас занимает
        if (mt[to] == -1 || try_kuhn(mt[to])) {
            mt[to] = v; // Соединяем v -> to
            return true;
        }
    }
    return false;
}

int main() {
    int n, k, m; // n - слева, k - справа, m - ребра
    cin >> n >> k >> m;

    for (int i = 0; i < m; ++i) {
        int u, v;
        cin >> u >> v;
        // u (1..n) -> v (1..k)
        u--; v--; // переходим к 0-индексации
        g[u].push_back(v);
    }

    // Инициализация паросочетания -1 (пусто)
    memset(mt, -1, sizeof(mt)); // Для массива mt размером k

    int matching_size = 0;
    for (int i = 0; i < n; ++i) {
        // Очищаем used перед каждым запуском для новой вершины из левой доли
        memset(used, 0, sizeof(used)); 
        if (try_kuhn(i)) {
            matching_size++;
        }
    }

    cout << "Maximum matching size: " << matching_size << endl;
    
    // Вывод самих пар
    for (int i = 0; i < k; ++i) {
        if (mt[i] != -1) {
            cout << mt[i] + 1 << " " << i + 1 << endl;
        }
    }
}
```

### Сложность
*   В худшем случае DFS проходит по всем ребрам ($E$).
*   Мы запускаем DFS для каждой вершины левой доли ($V$).
*   Итоговая сложность: **$O(V \cdot E)$**.

*Примечание:* На практике работает гораздо быстрее, так как увеличивающие цепи часто короткие. Для разреженных графов алгоритм очень эффективен.

### Оптимизации
1.  **Жадная инициализация:** Перед основным циклом можно пройтись по всем ребрам и добавить в паросочетание любые свободные пары. Это уменьшит количество запусков «тяжелого» DFS.
2.  **Ускорение `used`:** Вместо `memset` на каждой итерации можно использовать счетчик итераций (`used[v] == iteration_id`).

---

## 4. Связанные задачи (Классические теоремы)

Многие задачи сводятся к поиску максимального паросочетания, хотя формулируются иначе.

### 1. Минимальное вершинное покрытие (Minimum Vertex Cover)
**Задача:** Выбрать минимальное количество вершин так, чтобы каждое ребро графа имело хотя бы один конец в выбранном множестве.
**Теорема Кёнига:** В любом двудольном графе число ребер в максимальном паросочетании равно числу вершин в минимальном вершинном покрытии.
$$|MVC| = |MaxMatching|$$

**Алгоритм построения покрытия:**
1. Найти макс. паросочетание.
2. Ориентировать ребра:
   - Ребра из паросочетания: $R \to L$.
   - Остальные ребра: $L \to R$.
3. Запустить DFS из всех *свободных* вершин левой доли.
4. В покрытие берем:
   - Вершины $L$, которые **НЕ** были посещены DFS.
   - Вершины $R$, которые **БЫЛИ** посещены DFS.

### 2. Максимальное независимое множество (Maximum Independent Set)
**Задача:** Выбрать максимальное количество вершин, никакие две из которых не соединены ребром.
**Связь:** В любом графе $MIS$ является дополнением к $MVC$.
$$|MIS| = |V| - |MVC| = |V| - |MaxMatching|$$

### 3. Минимальное реберное покрытие (Minimum Edge Cover)
**Задача:** Выбрать мин. количество ребер, чтобы каждая вершина графа была концом хотя бы одного выбранного ребра (только для графов без изолированных вершин).
**Формула:**
$$|MEC| = |V| - |MaxMatching|$$

### 4. Минимальное покрытие путями (в DAG)
**Задача:** Дан ориентированный ациклический граф (DAG). Нужно покрыть все вершины минимальным количеством путей, не имеющих общих вершин.
**Решение:**
1. Строим двудольный граф: для каждой вершины $u$ исходного графа делаем $u_{left}$ и $u_{right}$.
2. Если есть ребро $u \to v$, добавляем ребро $u_{left} \to v_{right}$.
3. Ищем макс. паросочетание.
4. Ответ: $|V| - |MaxMatching|$.

---

## 5. Примеры задач и применения

1.  **Задачи на шахматной доске:**
    *   *Домино:* Можно ли замостить доску (с вырезанными клетками) костяшками домино $1 \times 2$?
    *   *Решение:* Раскрасим доску в шахматном порядке. Черные клетки — левая доля, белые — правая. Ребро есть, если клетки соседние. Ищем макс. паросочетание. Если $|MaxMatching| \times 2 =$ количеству клеток, то можно.

2.  **Распределение задач:**
    *   Есть $N$ сотрудников и $M$ задач. Каждый сотрудник умеет делать определенный набор задач. Какую максимальную загрузку можно обеспечить (1 задача — 1 человек)?
    *   *Решение:* Прямое применение алгоритма Куна.

3.  **Оптимизация:**
    *   Убрать минимальное количество предметов, чтобы оставшиеся не конфликтовали (см. Максимальное независимое множество).

---

## 6. Чек-лист для решения задач

1.  Можно ли представить задачу как граф?
2.  Является ли граф двудольным? (Нет циклов нечетной длины / Можно раскрасить в 2 цвета).
3.  Что нужно найти:
    *   Макс. число пар $\to$ **Паросочетание**.
    *   Мин. число вершин, блокирующих все ребра $\to$ **Вершинное покрытие**.
    *   Макс. число объектов, не мешающих друг другу $\to$ **Независимое множество**.
4.  Ограничения: Если $N, M \le 1000-2000$, Кун ($O(VE)$) подходит. Если $N, M \sim 10^5$, нужен алгоритм Хопкрофта-Карпа ($O(E\sqrt{V})$), но в олимпиадах Куна обычно достаточно за счет оптимизаций или специфики тестов.