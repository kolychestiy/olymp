# Динамическое программирование. Заключение

## 1. ДП по подотрезкам (Interval DP)

**Суть метода:**
Ответ для всего массива вычисляется через ответы для его подмассивов (подотрезков).
Мы пытаемся найти ответ для диапазона `[L, R]`, зная ответы для всех диапазонов `[l, r]`, которые вложены в него (имеют меньшую длину).

**Состояние:**
`dp[l][r]` — значение целевой функции для подотрезка от индекса `l` до `r` (включительно).

**Порядок обхода:**
Главная особенность: внешний цикл идет **по длине** подотрезка (`len`), а не по индексу `i`.
Сначала считаем все отрезки длины 1, потом длины 2, ..., в конце длины $N$.

### Базовая схема ($O(N^3)$)
```cpp
// n - размер массива
for (int len = 1; len <= n; ++len) {       // Длина отрезка
    for (int l = 0; l <= n - len; ++l) {   // Левая граница
        int r = l + len - 1;               // Правая граница
        
        if (len == 1) {
            dp[l][r] = ...; // База (для одного элемента)
        } else {
            dp[l][r] = INF;
            // Перебор точки разделения k
            for (int k = l; k < r; ++k) {
                // Пытаемся разбить [l, r] на [l, k] и [k+1, r]
                dp[l][r] = min(dp[l][r], dp[l][k] + dp[k+1][r] + cost(l, r));
            }
        }
    }
}
// Ответ обычно лежит в dp[0][n-1]
```

### Типовые задачи:
1.  **Перемножение матриц (Matrix Chain Multiplication):** Расставить скобки так, чтобы минимизировать число операций.
2.  **Склейка камней/слизней:** Есть ряд куч камней, можно объединять соседние, стоимость объединения равна сумме камней. Найти мин. стоимость объединения всего в одну кучу.
3.  **Удаление палиндромов:** Минимальное количество удалений палиндромов, чтобы очистить строку.
4.  **Правильные скобочные последовательности:** Посчитать количество ПСП длины $N$ (или восстановить пропущенные скобки).

---

## 2. ДП по маскам (Bitmask DP)

**Суть метода:**
Используется, когда $N$ мало (обычно $N \le 20$). Мы кодируем подмножество элементов с помощью целого числа (битовой маски).
Если $i$-й бит числа равен `1`, значит $i$-й элемент входит в множество, если `0` — нет.

**Битовые операции (Напоминание):**
*   Проверить $i$-й бит: `if ((mask >> i) & 1)`
*   Установить $i$-й бит: `mask | (1 << i)`
*   Снять $i$-й бит: `mask & ~(1 << i)`
*   Инвертировать $i$-й бит: `mask ^ (1 << i)`

**Сложность:** Обычно $O(2^N \cdot N)$ или $O(2^N \cdot N^2)$.

### Пример: Задача коммивояжера (TSP)
*Дано:* $N$ городов и расстояния между ними. Нужно посетить все города по одному разу и вернуться в начало, минимизировав путь.

**Состояние:**
`dp[mask][v]` — минимальная длина пути, который проходит через множество городов `mask` и заканчивается в городе `v`.

**Переход:**
Мы пришли в город `v` из какого-то города `u`, который уже был в маске.
`dp[mask][v] = min(dp[mask ^ (1<<v)][u] + dist[u][v])` для всех `u`, где $u \in mask, u \neq v$.

**Реализация:**
```cpp
// dp заполняем INF, dp[1][0] = 0 (стартуем в 0-м городе, маска 1)

for (int mask = 1; mask < (1 << n); ++mask) {
    for (int v = 0; v < n; ++v) {
        if ((mask >> v) & 1) { // Если v есть в маске
            
            int prev_mask = mask ^ (1 << v); // Маска без v
            if (prev_mask == 0) continue; 
            
            for (int u = 0; u < n; ++u) {
                if ((prev_mask >> u) & 1) { // Если u был в предыдущем состоянии
                    dp[mask][v] = min(dp[mask][v], dp[prev_mask][u] + dist[u][v]);
                }
            }
        }
    }
}
// Ответ: min(dp[(1<<n)-1][v] + dist[v][0])
```

---

## 3. Перебор подмасок (Submask Enumeration)

Иногда в задачах ДП по маскам нужно для текущей маски `mask` перебрать не просто отдельные биты, а **все её подмаски** (все подмножества данного множества).

**Наивный подход:**
Перебирать все числа от `0` до `mask`. Сложность $O(4^N)$ (суммарно для всех масок). Это слишком медленно.

**Оптимальный алгоритм:**
Существует способ перебрать только те числа, которые являются подмасками `m`.

```cpp
for (int s = m; s > 0; s = (s - 1) & m) {
    // s - является подмаской m
    // do something with s
}
```
*Как это работает:* Операция `s - 1` меняет последние нули на единицы и заимствует бит у первой встреченной справа единицы. Операция `& m` отсекает "лишние" единицы, которых нет в исходной маске `m`.

### Сложность $O(3^N)$
Почему это эффективно?
*   Для маски с $k$ единицами мы переберем $2^k$ подмасок.
*   Количество масок с $k$ единицами равно $C_n^k$ (биномиальный коэффициент).
*   Общее число операций: $\sum_{k=0}^{n} C_n^k \cdot 2^k = (1 + 2)^n = 3^n$.

Для $N=15$ это $\approx 14 \cdot 10^6$ операций (очень быстро).
Для $N=18$ это $\approx 3.8 \cdot 10^8$ операций (на пределе 1-2 секунд).

### Применение
Часто используется, когда состояние ДП можно разбить на два непересекающихся множества.
Например: покрасить вершины графа в $K$ цветов так, чтобы выполнялись условия.
`dp[mask] = min/sum/check( dp[submask] + value[mask ^ submask] )`

**Пример структуры кода:**
```cpp
for (int mask = 0; mask < (1 << n); ++mask) {
    // Перебираем все подмаски s маски mask
    for (int s = mask; s > 0; s = (s - 1) & mask) {
        // s - первая часть
        // mask ^ s - вторая часть (дополнение s до mask)
        
        // Пример: dp[mask] = min(dp[mask], dp[s] + calc(mask ^ s));
    }
}
```

---

## Итоговая шпаргалка

| Тип ДП | Ограничения | Состояние | Сложность |
| :--- | :--- | :--- | :--- |
| **Подотрезки** | $N \le 500$ | `dp[l][r]` (диапазон) | $O(N^3)$ (иногда $O(N^2)$) |
| **Маски** | $N \le 20$ | `dp[mask][...]` | $O(2^N \cdot poly(N))$ |
| **Подмаски** | $N \le 16-18$ | Перебор `s = (s-1)&m` | $O(3^N)$ |

**Совет:**
*   Если видите задачу, где можно "склеивать" соседние элементы — думайте про **ДП по подотрезкам**.
*   Если $N$ очень маленькое ($<20$) — думайте про **ДП по маскам**.
*   Если нужно разбить множество (маску) на две группы произвольным образом — используйте **перебор подмасок**.