# Наименьший общий предок (LCA)

## 1. Определение и базовые понятия

**Наименьший общий предок (LCA)** вершин $u$ и $v$ в корневом дереве — это вершина, которая является предком одновременно и для $u$, и для $v$, и при этом находится «ниже» (дальше от корня, который также будем обозначать как `root`) всех остальных общих предков.
Проще говоря, это место, где пути от $u$ и $v$ вверх к корню впервые встречаются.

**Свойства:**
*   $LCA(u, v) = u$, если $u$ является предком $v$.
*   $LCA(u, v) = LCA(v, u)$.
*   Расстояние между вершинами $dist(u, v) = depth[u] + depth[v] - 2 \cdot depth[LCA(u, v)]$.

##### Наивный алгоритм ($O(N)$):

Для каждой вершины знаем:

* `parent[v]` — родитель вершины (у корня `parent[root]=0`),
* `depth[v]` — глубина (расстояние от корня).

Тогда LCA(u, v) ищем так:

**Шаг 1. Выровнять глубины**

Если одна вершина глубже, поднимаем её по `parent[]`, пока глубины не сравняются.

**Шаг 2. Поднимать обе вершины одновременно**

Пока `u != v`, делаем:

* `u = parent[u]`
* `v = parent[v]`

Когда встретились — это и есть **LCA**.

---

**наивный LCA** в дереве: один запрос работает за **(O(H))**, где (H) — высота дерева (в худшем случае (H=N), если дерево — “бамбук”). Для множества запросов это плохо: (Q) запросов дадут O(QN) времени.

---

## Полный код на C++ (preprocess + запросы)

Код читает:

* (N),
* (N-1) ребро (неориентированные),
* (Q) запросов `u v`,
  и выводит LCA для каждого запроса.

```cpp
#include <bits/stdc++.h>
using namespace std;

// Наивный LCA: O(H) на запрос, где H — высота дерева (до N).
// Предобработка: parent[] и depth[] за O(N).

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);

    int n;
    cin >> n;

    vector<vector<int>> g(n + 1);
    for (int i = 0; i < n - 1; i++) {
        int a, b;
        cin >> a >> b;
        g[a].push_back(b);
        g[b].push_back(a);
    }

    int root = 1;

    vector<int> parent(n + 1, 0);
    vector<int> depth(n + 1, 0);

    // BFS/DFS для вычисления parent и depth
    queue<int> q;
    q.push(root);
    parent[root] = 0;
    depth[root] = 0;

    while (!q.empty()) {
        int v = q.front();
        q.pop();
        for (int to : g[v]) {
            if (to == parent[v]) continue;
            parent[to] = v;
            depth[to] = depth[v] + 1;
            q.push(to);
        }
    }

    auto lca_naive = [&](int u, int v) {
        // 1) выровнять глубины
        while (depth[u] > depth[v]) u = parent[u];
        while (depth[v] > depth[u]) v = parent[v];

        // 2) поднимать одновременно
        while (u != v) {
            u = parent[u];
            v = parent[v];
        }
        return u; // здесь u == v
    };

    int Q;
    cin >> Q;
    while (Q--) {
        int u, v;
        cin >> u >> v;
        cout << lca_naive(u, v) << "\n";
    }

    return 0;
}
```

---

## 2. LCA через Двоичные подъёмы (Binary Lifting)

Это самый популярный метод («золотой стандарт» олимпиадного программирования). Он позволяет отвечать на запрос за **$O(\log N)$** при препроцессе **$O(N \log N)$** времени и памяти. Этот метод является по сути применением идеи бинарного поиска к описанному выше тривиальному подходу.

### Идея
Для каждой вершины мы предпосчитываем не только непосредственного родителя, но и предков на расстояниях $1, 2, 4, 8, \dots, 2^k$ ($2^{k + 1} \ge n, 2^k < n$).

*   `up[v][i]` — предок вершины $v$ на расстоянии $2^i$.
*   `up[v][0]` — это просто родитель вершины.

Также нам понадобится ещё один массив

* `depth[v]` — глубина вершины.

### Динамика
Чтобы найти предка на расстоянии $2^i$, можно сделать прыжок на $2^{i-1}$, а затем из той точки еще один прыжок на $2^{i-1}$ ($2^{i-1} + 2^{i-1} = 2^i$).

Формула:
$$up[v][i] = up[\; up[v][i-1] \;][i-1]$$

Поскольку любое число однозначно раскладывается в сумму степеней двойки (что можно легко понять, на примере битовой записи числа, где $1$ в $i$-м бите обозначает что в разложении будет слагаемое $2^i$), можно подниматься вверх на произвольную глубину за `O(log n)`.

### Препроцессинг

внутри DFS:

1. Заполняем `depth`
2. Записываем родителя
3. Строим строку `up[v][*]` (можно построить и после DFS)

### Алгоритм ответа на запрос LCA(u, v)
1.  **Выравнивание глубин:** Не умаляя общности, пусть $depth[u] \ge depth[v]$. Мы поднимаем $u$ вверх, пока ее глубина не станет равной глубине $v$. Для этого используем двоичные подъемы. Можно либо перебирать $k$ в порядке убывания, и прыгать на $2^k$ вверх, если это не поднимает нас выше $v$, либо пройтись циклом по битам числа $depth[u] - depth[v]$ и прыгать на те $2^k$, где есть $1$ в $k$-м бите этого числа.
2.  **Проверка совпадения:** Если после выравнивания $u == v$, значит $v$ была предком $u$, ответ найден.
3.  **Совместный подъем:** Поднимаем обе вершины одновременно. Перебираем $i$ от макс. степени до $0$ (в порядке убывания). Если `up[u][i] != up[v][i]` (прыжок $2^i$ не приводит их в одну точку), то совершаем прыжок: $u = up[u][i], v = up[v][i]$.
4.  **Ответ:** После цикла из п.3, $u$ и $v$ будут находиться прямо под LCA. Ответ: `up[u][0]`.

### Реализация (C++)

```cpp
const int MAXN = 100000 + 5;
const int LOG = 20; // подходит для n <= 1e6

vector<int> g[MAXN];
int up[MAXN][LOG];
int depth[MAXN];
int n;
int l; // максимальная степень

void dfs(int v, int p) {
    up[v][0] = p;

    for (int i = 1; i <= l; i++) {
        up[v][i] = up[ up[v][i-1] ][i-1];
    }

    for (int to : g[v]) {
        if (to == p) continue;
        depth[to] = depth[v] + 1;
        dfs(to, v);
    }
}

void precompute(int root) {
    l = 0;
    while ((1 << (l + 1)) <= n) l++;

    depth[root] = 0;
    dfs(root, root);
}

int lca(int u, int v) {

    if (depth[u] < depth[v])
        swap(u, v);

    // 1. Выравнивание глубин
    int diff = depth[u] - depth[v];
    for (int i = l; i >= 0; i--) {
        if (diff & (1 << i)) {
            u = up[u][i];
        }
    }

    // 2. Если совпали
    if (u == v)
        return u;

    // 3. Совместный подъём
    for (int i = l; i >= 0; i--) {
        if (up[u][i] != up[v][i]) {
            u = up[u][i];
            v = up[v][i];
        }
    }

    // 4. Ответ
    return up[u][0];
}
```

Также приведём несколько альтернативный подход, использующий `tin` и `tout` для функции `is_ancestor`, тем самым несколько упрощающий функцию `lca`:

```cpp
const int MAXN = 100005;
const int LOG = 20; // 2^20 > 100000

vector<int> g[MAXN];
int up[MAXN][LOG]; // Таблица подъемов
int tin[MAXN], tout[MAXN]; // Время входа/выхода (для проверки на предка)
int depth[MAXN];
int timer;
int n, l; // l = ceil(log2(n))

void dfs(int v, int p, int d) {
    tin[v] = ++timer;
    depth[v] = d;
    up[v][0] = p;
    
    // Заполняем таблицу подъемов
    for (int i = 1; i <= l; ++i) {
        up[v][i] = up[up[v][i-1]][i-1];
    }
    
    for (int to : g[v]) {
        if (to != p) dfs(to, v, d + 1);
    }
    tout[v] = ++timer;
}

// Проверка: является ли u предком v
bool is_ancestor(int u, int v) {
    return tin[u] <= tin[v] && tout[u] >= tout[v];
}

int lca(int u, int v) {
    if (is_ancestor(u, v)) return u;
    if (is_ancestor(v, u)) return v;
    
    for (int i = l; i >= 0; --i) {
        // Если прыжок 2^i не делает up[u][i] предком v, то прыгаем
        if (!is_ancestor(up[u][i], v)) {
            u = up[u][i];
        }
    }
    return up[u][0];
}

void precompute(int root) {
    l = ceil(log2(n));
    timer = 0;
    // up[root][...] будет указывать на root, если сделать проверку
    dfs(root, root, 0); 
}
```

### Инвариант корректности

На этапе совместного подъёма выполняется инвариант:

* `u` и `v` находятся на одинаковой глубине
* `LCA(u, v)` — предок обеих вершин
* мы никогда не поднимаемся выше LCA

Цикл гарантирует, что после него:

$$u \neq v,\quad up[u][0] = up[v][0] = LCA$$

---

## 3. LCA через Эйлеров обход и RMQ

Этот метод позволяет отвечать на запросы за $O(1)$ (константное время), но требует построения разреженной таблицы (Sparse Table) за $O(N \log N)$ времени и памяти. Если вместо Sparse Table использовать Дерево отрезков, то достигается $O(\log N)$ времени на запрос, но препроцесс занимает $O(N)$ времени и памяти. А если использовать алгоритм Фарах-Колтона и Бендера, то и вовсе достигается прекальк за $O(N)$ времени и памяти, и $O(1)$ времени на запрос (правда на практике этот алгоритм не нужен, так как имеет большую константу времени работы, но зато он позволяет решать любую задачу RMQ за такую асимптотику, не только для LCA).

### Идея
Сведем задачу LCA к задаче **RMQ (Range Minimum Query)** — поиск минимума на отрезке.

1.  **Эйлеров обход:** Запустим DFS. Будем записывать вершину в список `nodes` **каждый раз**, когда посещаем её (при входе и при возврате от сыновей).
2.  Также запишем глубину каждой вершины в список `depths` параллельно списку `nodes` (то есть добавляя вершину в `nodes` мы одновременно добавляем её глубину в `depths`).
3.  Для каждой вершины $v$ запомним индекс её **первого вхождения** в список `nodes` — `first[v]` (это есть по сути `tin[v]`).

В таком обходе между первым вхождением $u$ и первым вхождением $v$ будут перечислены все вершины поддерева LCA, а также само LCA, причем LCA будет иметь **минимальную глубину** на этом отрезке.

### Формализация
Пусть `first[u] < first[v]`.
$LCA(u, v)$ — это вершина из массива `nodes` на отрезке `[first[u], first[v]]`, у которой значение в массиве `depths` минимально.

### Пример

![](\img\tree5.png)

Обход DFS:
1.  Входим в 1. `nodes`: [1], `depths`: [0]
2.  Идем в 2. `nodes`: [1, 2], `depths`: [0, 1]
3.  Идем в 4. `nodes`: [1, 2, 4], `depths`: [0, 1, 2]
4.  Возврат в 2. `nodes`: [1, 2, 4, 2], `depths`: [0, 1, 2, 1]
5.  Идем в 5. `nodes`: [1, 2, 4, 2, 5], `depths`: [0, 1, 2, 1, 2]
6.  Возврат в 2. `nodes`: [1, 2, 4, 2, 5, 2], `depths`: [0, 1, 2, 1, 2, 1]
7.  Возврат в 1. `nodes`: [1, 2, 4, 2, 5, 2, 1], `depths`: [0, 1, 2, 1, 2, 1, 0]
...и так далее.

Чтобы найти LCA(4, 5):
Индексы: `first[4]=2`, `first[5]=4`.
Отрезок в `nodes`: `[4, 2, 5]`. Глубины: `[2, 1, 2]`.
Минимум глубины = 1. Соответствующая вершина = 2.
LCA(4, 5) = 2.

### Реализация

```cpp
#include <bits/stdc++.h>
using namespace std;

struct LCA {
    int n;
    vector<vector<int>> g;

    vector<int> nodes;   // euler tour: вершины
    vector<int> depths;  // euler tour: глубины соответствующих nodes
    vector<int> first;   // first[v] = индекс первого вхождения v в nodes

    vector<int> lg;                  // lg[i] = floor(log2(i))
    vector<vector<int>> st;          // st[k][i] = индекс в euler (nodes/depths) с min depth на [i, i+2^k-1]

    LCA(int n = 0) : n(n), g(n + 1), first(n + 1, -1) {}

    void add_edge(int u, int v) {
        g[u].push_back(v);
        g[v].push_back(u);
    }

    void dfs(int v, int d, int p = -1) {
        first[v] = (int)nodes.size();
        nodes.push_back(v);
        depths.push_back(d);

        for (int to : g[v]) {
            if (to == p) continue;
            dfs(to, d + 1, v);
            nodes.push_back(v);      // при возврате
            depths.push_back(d);
        }
    }

    void build(int root = 1) {
        nodes.clear();
        depths.clear();
        fill(first.begin(), first.end(), -1);

        dfs(root, 0, -1);

        int m = (int)nodes.size();
        lg.assign(m + 1, 0);
        for (int i = 2; i <= m; i++) lg[i] = lg[i / 2] + 1;

        int K = lg[m] + 1;
        st.assign(K, vector<int>(m));

        for (int i = 0; i < m; i++) st[0][i] = i;

        for (int k = 1; k < K; k++) {
            int len = 1 << k;
            for (int i = 0; i + len <= m; i++) {
                int i1 = st[k - 1][i];
                int i2 = st[k - 1][i + (len >> 1)];
                st[k][i] = (depths[i1] < depths[i2] ? i1 : i2);
            }
        }
    }

    int rmq_index(int l, int r) const {
        if (l > r) swap(l, r);
        int k = lg[r - l + 1];
        int i1 = st[k][l];
        int i2 = st[k][r - (1 << k) + 1];
        return (depths[i1] < depths[i2] ? i1 : i2);
    }

    int lca(int u, int v) const {
        int idx = rmq_index(first[u], first[v]);
        return nodes[idx];
    }

    int dist(int u, int v) const {
        int w = lca(u, v);
        int du = depths[first[u]];
        int dv = depths[first[v]];
        int dw = depths[first[w]];
        return du + dv - 2 * dw;
    }
};

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);

    int n, q;
    cin >> n >> q;

    LCA solver(n);
    for (int i = 0; i < n - 1; i++) {
        int u, v;
        cin >> u >> v;
        solver.add_edge(u, v);
    }

    solver.build(1); // корень = 1 (поменяй, если нужно)

    while (q--) {
        int u, v;
        cin >> u >> v;
        cout << solver.lca(u, v) << "\n";
    }
    return 0;
}
```

### Сравнение методов

| Метод | Препроцессинг | Время запроса | Память | Особенности |
| :--- | :--- | :--- | :--- | :--- |
| **Двоичные подъемы** | $O(N \log N)$ | $O(\log N)$ | $O(N \log N)$ | Легко пишется, работает с динамическим добавлением листьев. |
| **Эйлеров обход + Sparse Table** | $O(N \log N)$ | $O(1)$ | $O(N \log N)$ | Быстрый запрос. Сложно менять дерево (статический метод). |
| **Эйлеров обход + Дерево отрезков** | $O(N)$ | $O(\log N)$ | $O(N)$ | Быстрый прекальк, но не быстрый запрос. Сложно менять дерево (статический метод). |
| **Метод Фарах-Колтона** | $O(N)$ | $O(1)$ | $O(N)$ | Очень сложная реализация (RMQ ±1), примерно никогда не нужна на олимпиадах. |

**Рекомендация:** На большинстве олимпиад достаточно **двоичных подъемов**. Если тайм-лимит очень жесткий (много запросов), используйте Эйлеров обход + Sparse Table.