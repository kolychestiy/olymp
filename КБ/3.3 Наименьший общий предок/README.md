# Наименьший общий предок (LCA)

## 1. Определение и базовые понятия

**Наименьший общий предок (LCA)** вершин $u$ и $v$ в корневом дереве — это вершина, которая является предком одновременно и для $u$, и для $v$, и при этом находится «ниже» (дальше от корня) всех остальных общих предков.
Проще говоря, это место, где пути от $u$ и $v$ вверх к корню впервые встречаются.

**Свойства:**
*   $LCA(u, v) = u$, если $u$ является предком $v$.
*   $LCA(u, v) = LCA(v, u)$.
*   Расстояние между вершинами $dist(u, v) = depth[u] + depth[v] - 2 \cdot depth[LCA(u, v)]$.

**Наивный алгоритм ($O(N)$):**
Поднимать обе вершины вверх на один уровень, пока они не встретятся. В худшем случае (линия) это слишком медленно для множественных запросов.

---

## 2. LCA через Двоичные подъёмы (Binary Lifting)

Это самый популярный метод («золотой стандарт» олимпиадного программирования). Он позволяет отвечать на запрос за **$O(\log N)$** при подготовке **$O(N \log N)$**.

### Идея
Для каждой вершины мы предпосчитываем не только непосредственного родителя, но и предков на расстояниях $1, 2, 4, 8, \dots, 2^k$.

*   `up[v][i]` — предок вершины $v$ на расстоянии $2^i$.
*   `up[v][0]` — это просто родитель вершины.

### Динамика
Чтобы найти предка на расстоянии $2^i$, можно сделать прыжок на $2^{i-1}$, а затем из той точки еще один прыжок на $2^{i-1}$ ($2^{i-1} + 2^{i-1} = 2^i$).

Формула:
$$up[v][i] = up[\; up[v][i-1] \;][i-1]$$

### Алгоритм ответа на запрос LCA(u, v)
1.  **Выравнивание глубин:** Пусть $depth[u] > depth[v]$. Мы поднимаем $u$ вверх, пока ее глубина не станет равной глубине $v$. Для этого используем двоичные подъемы (прыгаем на большие степени двойки, если они не уводят нас выше уровня $v$).
2.  **Проверка совпадения:** Если после выравнивания $u == v$, значит $v$ была предком $u$, ответ найден.
3.  **Совместный подъем:** Поднимаем обе вершины одновременно. Перебираем $i$ от макс. степени до $0$. Если `up[u][i] != up[v][i]` (прыжок $2^i$ не приводит их в одну точку), то совершаем прыжок: $u = up[u][i], v = up[v][i]$.
4.  **Ответ:** После цикла $u$ и $v$ будут находиться прямо под LCA. Ответ: `up[u][0]`.

### Реализация (C++)

```cpp
const int MAXN = 100005;
const int LOG = 20; // 2^20 > 100000

vector<int> g[MAXN];
int up[MAXN][LOG]; // Таблица подъемов
int tin[MAXN], tout[MAXN]; // Время входа/выхода (для проверки на предка)
int depth[MAXN];
int timer;
int n, l; // l = ceil(log2(n))

void dfs(int v, int p, int d) {
    tin[v] = ++timer;
    depth[v] = d;
    up[v][0] = p;
    
    // Заполняем таблицу подъемов
    for (int i = 1; i <= l; ++i) {
        up[v][i] = up[up[v][i-1]][i-1];
    }
    
    for (int to : g[v]) {
        if (to != p) dfs(to, v, d + 1);
    }
    tout[v] = ++timer;
}

// Проверка: является ли u предком v
bool is_ancestor(int u, int v) {
    return tin[u] <= tin[v] && tout[u] >= tout[v];
}

int lca(int u, int v) {
    if (is_ancestor(u, v)) return u;
    if (is_ancestor(v, u)) return v;
    
    for (int i = l; i >= 0; --i) {
        // Если прыжок 2^i не делает up[u][i] предком v, то прыгаем
        if (!is_ancestor(up[u][i], v)) {
            u = up[u][i];
        }
    }
    return up[u][0];
}

void precompute(int root) {
    l = ceil(log2(n));
    timer = 0;
    // up[root][...] будет указывать на root, если сделать проверку
    dfs(root, root, 0); 
}
```
*Примечание:* В коде выше использован метод `is_ancestor` для упрощения логики. Это немного отличается от классического подъема «по глубине», но работает так же и код короче.

---

## 3. LCA через Эйлеров обход и RMQ

Этот метод позволяет отвечать на запросы за **$O(1)$** (константное время), но требует построения разреженной таблицы (Sparse Table) за $O(N \log N)$.

### Идея
Сведем задачу LCA к задаче **RMQ (Range Minimum Query)** — поиске минимума на отрезке.

1.  **Эйлеров обход:** Запустим DFS. Будем записывать вершину в список `nodes` **каждый раз**, когда посещаем её (при входе и при возврате от сыновей).
2.  Также запишем глубину каждой вершины в список `depths` параллельно списку `nodes`.
3.  Для каждой вершины $v$ запомним индекс её **первого вхождения** в список `nodes` — `first[v]`.

В таком обходе между первым вхождением $u$ и первым вхождением $v$ будут перечислены все вершины поддерева LCA, а также само LCA, причем LCA будет иметь **минимальную глубину** на этом отрезке.

### Формализация
Пусть `first[u] < first[v]`.
$LCA(u, v)$ — это вершина из массива `nodes` на отрезке `[first[u], first[v]]`, у которой значение в массиве `depths` минимально.

### Пример
Дерево: 1 -> (2, 3), 2 -> (4, 5).
Обход DFS:
1.  Входим в 1. `nodes`: [1], `depths`: [0]
2.  Идем в 2. `nodes`: [1, 2], `depths`: [0, 1]
3.  Идем в 4. `nodes`: [1, 2, 4], `depths`: [0, 1, 2]
4.  Возврат в 2. `nodes`: [1, 2, 4, 2], `depths`: [0, 1, 2, 1]
5.  Идем в 5. `nodes`: [1, 2, 4, 2, 5], `depths`: [0, 1, 2, 1, 2]
6.  Возврат в 2. `nodes`: [1, 2, 4, 2, 5, 2], `depths`: [0, 1, 2, 1, 2, 1]
7.  Возврат в 1. `nodes`: [1, 2, 4, 2, 5, 2, 1], `depths`: [0, 1, 2, 1, 2, 1, 0]
...и так далее.

Чтобы найти LCA(4, 5):
Индексы: `first[4]=2`, `first[5]=4`.
Отрезок в `nodes`: `[4, 2, 5]`. Глубины: `[2, 1, 2]`.
Минимум глубины = 1. Соответствующая вершина = 2.
LCA(4, 5) = 2.

### Реализация (Схема)

1.  **DFS:**
    ```cpp
    vector<int> nodes;
    vector<int> depths;
    int first[MAXN];
    
    void dfs(int v, int d, int p = -1) {
        first[v] = nodes.size();
        nodes.push_back(v);
        depths.push_back(d);
        
        for (int to : g[v]) {
            if (to == p) continue;
            dfs(to, d + 1, v);
            nodes.push_back(v);      // Добавляем v снова при возврате
            depths.push_back(d);
        }
    }
    ```
    Размер массивов будет $2N - 1$.

2.  **Sparse Table (Разреженная таблица):**
    Строим Sparse Table на массиве `depths`. Однако нам нужно возвращать не саму минимальную глубину, а **индекс** или **вершину**, где этот минимум достигается.
    Удобнее хранить в ST пару `{depth, node_index}` или просто сравнивать глубины, но хранить индексы.

3.  **Запрос:**
    Получаем $L = first[u], R = first[v]$.
    Если $L > R$, меняем местами.
    Делаем запрос RMQ на отрезке $[L, R]$.

### Сравнение методов

| Метод | Препроцессинг | Время запроса | Память | Особенности |
| :--- | :--- | :--- | :--- | :--- |
| **Двоичные подъемы** | $O(N \log N)$ | $O(\log N)$ | $O(N \log N)$ | Легко пишется, работает с динамическим добавлением листьев. |
| **Эйлеров обход + RMQ** | $O(N \log N)$ | $O(1)$ | $O(N \log N)$ | Быстрый запрос. Сложно менять дерево (статический метод). |
| **Метод Фарах-Колтона** | $O(N)$ | $O(1)$ | $O(N)$ | Очень сложная реализация (RMQ ±1), редко нужна на олимпиадах. |

**Рекомендация:** На большинстве олимпиад достаточно **двоичных подъемов**. Если тайм-лимит очень жесткий (много запросов, $N, Q \le 5 \cdot 10^5$), используйте Эйлеров обход + Sparse Table.