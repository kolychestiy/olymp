# Дерево отрезков. Разреженная таблица

## 1. Разреженная таблица (Sparse Table)

**Разреженная таблица** — это статическая структура данных, позволяющая отвечать на запросы на отрезке за $O(1)$ (для идемпотентных операций) или $O(\log N)$ (для остальных).

**Особенности:**
*   **Immutable:** Массив не должен меняться между запросами (нет операций update).
*   **Идемпотентность:** Идеальна для операций, где $f(x, x) = x$ (минимум, максимум, НОД, битовые операции OR/AND).
*   **Время построения:** $O(N \log N)$.
*   **Память:** $O(N \log N)$.

### Принцип работы
Мы предподсчитываем значения функции для всех отрезков длины $2^k$ ($1, 2, 4, 8 \dots$).
Пусть `st[k][i]` хранит значение функции на отрезке, начинающемся в `i` и имеющем длину $2^k$.

$$st[k][i] = \min(st[k-1][i], \ st[k-1][i + 2^{k-1}])$$

### Реализация (Range Minimum Query — RMQ)

```cpp
const int MAXN = 100005;
const int K = 20; // K такое, что 2^K > MAXN
int st[K][MAXN];
int lg[MAXN]; // Массив логарифмов

void build(const vector<int>& a) {
    int n = a.size();
    
    // Предподсчет логарифмов
    lg[1] = 0;
    for (int i = 2; i <= n; i++)
        lg[i] = lg[i/2] + 1;

    // База: отрезки длины 1
    for (int i = 0; i < n; i++)
        st[0][i] = a[i];

    // Динамика
    for (int k = 1; k < K; k++) {
        for (int i = 0; i + (1 << k) <= n; i++) {
            st[k][i] = min(st[k-1][i], st[k-1][i + (1 << (k-1))]);
        }
    }
}

// Запрос минимума на [L, R] за O(1)
int query(int L, int R) { // L и R включительно, 0-индексация
    int j = lg[R - L + 1];
    return min(st[j][L], st[j][R - (1 << j) + 1]);
}
```
*Суть запроса:* Любой отрезок $[L, R]$ покрывается двумя накладывающимися друг на друга отрезками длины $2^j$.

---

## 2. Дерево отрезков (Segment Tree)

**Дерево отрезков (ДО)** — универсальная структура данных для запросов на отрезках и **обновления** элементов.

**Характеристики:**
*   **Построение:** $O(N)$.
*   **Запрос (Sum, Min, Max):** $O(\log N)$.
*   **Обновление (точка):** $O(\log N)$.
*   **Память:** $4N$ (для безопасного хранения в массиве).

### Структура
Дерево является бинарным.
*   Корень отвечает за отрезок $[0, N-1]$.
*   Вершина $v$ отвечает за $[tl, tr]$. Левый сын ($2v$) за $[tl, tm]$, правый ($2v+1$) за $[tm+1, tr]$, где $tm = (tl+tr)/2$.
*   Листья отвечают за конкретные элементы массива.

### Реализация (Сумма на отрезке)

```cpp
const int MAXN = 100000;
long long t[4 * MAXN]; // Массив дерева

// Построение
void build(const vector<int>& a, int v, int tl, int tr) {
    if (tl == tr) {
        t[v] = a[tl];
    } else {
        int tm = (tl + tr) / 2;
        build(a, 2*v, tl, tm);
        build(a, 2*v+1, tm+1, tr);
        t[v] = t[2*v] + t[2*v+1];
    }
}

// Обновление элемента: a[pos] = new_val
void update(int v, int tl, int tr, int pos, int new_val) {
    if (tl == tr) {
        t[v] = new_val;
    } else {
        int tm = (tl + tr) / 2;
        if (pos <= tm)
            update(2*v, tl, tm, pos, new_val);
        else
            update(2*v+1, tm+1, tr, pos, new_val);
        t[v] = t[2*v] + t[2*v+1]; // Пересчет при возврате
    }
}

// Запрос суммы на [l, r]
long long query(int v, int tl, int tr, int l, int r) {
    if (l > r) 
        return 0; // Пустой отрезок
    if (l == tl && r == tr) {
        return t[v]; // Полное совпадение
    }
    int tm = (tl + tr) / 2;
    // Разбиваем запрос на две части
    return query(2*v, tl, tm, l, min(r, tm)) +
           query(2*v+1, tm+1, tr, max(l, tm+1), r);
}
```
**Вызов функций:** Корень всегда имеет индекс 1, границы $0$ и $n-1$.
Пример: `query(1, 0, n-1, L, R)`.

---

## 3. Основы метода сканирующей прямой (Scanline)

**Метод сканирующей прямой** — это алгоритмический подход к решению геометрических задач, заключающийся в «проведении» воображаемой прямой через плоскость (обычно слева направо).

### Алгоритм
1.  **События (Events):**
    Геометрические фигуры проецируются на ось сканирования. Важны только моменты, когда статус системы меняется (начало отрезка, конец отрезка, точка запроса).
2.  **Сортировка:**
    События сортируются по координате (времени). Если координаты равны, порядок определяется типом события (сначала обработать «открывающие», потом «запросы», потом «закрывающие»).
3.  **Обработка:**
    Проходим по отсортированным событиям. Между двумя соседними событиями состояние «среза» не меняется.
4.  **Структура данных:**
    Для эффективной обработки «активных» объектов в текущем срезе часто используется Дерево отрезков.

### Классическая задача: Длина объединения отрезков на прямой
Дано $N$ отрезков $[L_i, R_i]$. Найти длину их объединения.

1.  Создаем события:
    *   Для каждого отрезка $[L, R]$ создаем два события: `(L, +1)` и `(R, -1)`.
2.  Сортируем события по координате.
3.  Идем циклом. Переменная `counter` хранит количество открытых в данный момент отрезков.
    *   Прибавляем к ответу `(current_x - prev_x)`, если `counter > 0`.
    *   Обновляем `counter` значением типа события (+1 или -1).
    *   `prev_x = current_x`.

### Классическая задача: Площадь объединения прямоугольников
Даны прямоугольники $(x1, y1, x2, y2)$. Найти площадь их объединения.

1.  Сканирующая прямая движется вертикально (по $X$).
2.  События — вертикальные границы прямоугольников:
    *   $x1$: добавить отрезок $[y1, y2]$ в структуру.
    *   $x2$: удалить отрезок $[y1, y2]$ из структуры.
3.  **Структура (Дерево отрезков):**
    ДО строится над координатами $Y$. Оно должно отвечать на вопрос: какова длина объединения активных отрезков по оси $Y$ сейчас?
4.  **Алгоритм:**
    *   Сортируем вертикальные линии по $X$.
    *   Идем от $X_i$ к $X_{i+1}$.
    *   Площадь += $(X_{i+1} - X_i) \times (\text{длина занятого Y})$.
    *   Обновляем ДО (добавляем/удаляем отрезок $[y1, y2]$).

### Краткий итог по выбору
*   **Нужен минимум на отрезке и массив не меняется?** $\rightarrow$ **Разреженная таблица**.
*   **Нужна сумма/минимум и есть изменения элементов?** $\rightarrow$ **Дерево отрезков**.
*   **Геометрическая задача (площади, пересечения)?** $\rightarrow$ **Сканирующая прямая + Дерево отрезков**.