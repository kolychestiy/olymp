# Математика. Часть 1 

## Арифметика остатков по модулю

#### Зачем она нужна?
В олимпиадных задачах часто просят вывести ответ «по модулю $10^9 + 7$» или другого большого числа. Это делается для того, чтобы:
1.  Избежать работы с длинной арифметикой (числами, которые не влезают в `long long`).
2.  Проверить корректность алгоритма на больших данных без необходимости хранить гигантские числа.

**Интуиция:** Представьте часы. Арифметика по модулю 12 — это то, как мы считаем время. $13:00$ это то же самое, что $1:00$ ($13 \equiv 1 \pmod{12}$).

#### Частное и остаток

Для любых целых чисел $a$ и $b$ (где $b > 0$) существуют единственные целые числа $q$ (частное) и $r$ (остаток) такие, что:
$a = b \cdot q + r$, где $0 \le r < b$.

Пример: $\frac{17}{5} = 3$ (частное) и остаток $2$. Записывается: $17 = 5 * 3 + 2$.

#### Определение сравнения по модулю

Говорят, что два числа $a$ и $b$ сравнимы по модулю $m$ (где $m$ — целое положительное число), если они дают одинаковый остаток при делении на $m$. Это записывается так:

$a \equiv b \pmod{m}$

Это эквивалентно тому, что разность $(a - b)$ делится на $m$ нацело.

Примеры:

$17 \equiv 2 \pmod{5}$, потому что и $17$, и $2$ при делении на $5$ дают остаток $2$. (Или потому что $17 - 2 = 15$ делится на $5$).

$14 \equiv 8 \pmod{3}$

$20 \equiv 0 \pmod{5}$

Важно: В программировании операция взятия остатка часто обозначается как `%`.
`a % m` — это и есть остаток от деления a на m. Так что $a \equiv b \pmod{m}$ означает, что `a % m == b % m`.

#### Основные свойства

Операции сложения, вычитания и умножения можно выполнять **на каждом шаге**, не дожидаясь конца вычислений.

1.  **Сложение:**
    $$(a + b) \pmod m = ((a \pmod m) + (b \pmod m)) \pmod m$$
2.  **Умножение:**
    $$(a \cdot b) \pmod m = ((a \pmod m) \cdot (b \pmod m)) \pmod m$$
3.  **Вычитание (ВАЖНО!):**
    $$(a - b) \pmod m \neq ((a \pmod m) - (b \pmod m)) \pmod m \quad (\text{в C++})$$
4.  **Деление (ВАЖНО!):** Деление как таковое не определено в модульной арифметике. Вместо него используется домножение на обратное число, о чём будет сказано позднее.

#### Проблема отрицательных чисел в C++

В математике остаток от деления всегда неотрицательный ($0 \le r < m$).
В C++ оператор `%` для отрицательных чисел возвращает отрицательный результат (в угоду производительности):
`-5 % 3` вернет `-2`, а нам нужно `1`.

**Правильная формула вычитания:**
$$ (a - b) \pmod m = ((a - b) \pmod m + m) \pmod m $$

**Код:**
```cpp
int sub(int a, int b, int m) {
    return ((a - b) % m + m) % m;
}
```

Если $a$ и $b$ уже являются остатками по модулю $m$ (т.е. $0 \le a, b < m$>), то можно избавиться от одного процента:

```cpp
int sub(int a, int b, int m) {
    return (a - b + m) % m;
}
```

#### Время выполнения

Взятие остатка от деления очень дорогая операция (наравне с делением), потому по возможности можно стараться избегать её использования. Так например, можно заменить код выше на следующий:

```cpp
int sub(int a, int b, int m) {
    int res = a - b;
    if (res < 0) res += m;
    return res;
}
```

Аналогично можно поступить и со сложением:

```cpp
int add(int a, int b, int m) {
    int res = a + b;
    if (res >= m) res -= m;
    return res;
}
```

Все это справедливо если $0 \le a, b < m$. Однако, в большинстве задач можно этим принебречь, и использовать `%`.

Приведём также пример умножения:

```cpp
int mul(int a, int b, int m) {
    return 1ll * a * b % m;
}
```

Обратите внимание, что при работе с целыми числами при умножении часто может произойти переполнение (обычно $m$ примерно равно $10^9$).

## Быстрое возведение в степень

**Задача**: даны $a$ и $k$, нужно найти значение $a^k \pmod{m}$.

**Тривиальное решение**: Сделаем цикл на $k$ итераций, который будет постепенно умножать ответ на $a$, пока не сделает $k$ умножений:

```cpp
    long long ans = 1;
    for (int i = 0; i < k; i++) {
        ans = ans * a % m;
    }
    return ans;
```

Время работы $\mathcal{O}(k)$. А далее нам понадбится уметь решать эту задачу сильно быстрее.

**Ключевая идея**: Если $k$ чётное, то $a^k = a^{k/2} * a^{k/2}$. То есть можно вычислить ответ для $k / 2$ и возвести в квадрат за одно умножение. Если $k$ нечётное, то $a^k = a^{k-1} * a$, переходим к чётному. Таким образом, мы за $2$ шага гарантированно уменьшим $k$ хотя бы в $2$ раза, а значит итоговое время работы будет $\mathcal{O}(\log k)$.

```cpp
long long binpow(long long a, long long k) {
    if (k == 0) return 1;
    if (k & 1) return a * binpow(a, k - 1) % m;
    return binpow(a * a % m, k / 2); // см. пояснение ниже
}
```

В этом коде мы воспользовались следующим преобразованием, для упрощения кода: $a^k = a^{k/2} * a^{k/2} = (a^{k/2})^2 = (a^2)^{k/2}$.

В качестве упражнения для самостоятельной работы, предлагается подумать, как реализовать нерекурсивное бинарное возведение в степень.

## Малая теорефма Ферма. Деление по модулю

### Теорема

Пусть $p$ $-$ простое число и $0 < a < p$ целое число. Тогда верно $a^{p-1} \equiv 1 \pmod p$.

### Доказательство

Сначала докажем, что $1 \cdot 2 \cdot \ldots \cdot (p-1) \equiv (1 \cdot a) \cdot (2 \cdot a) \cdot \ldots \cdot ((p-1) \cdot a) \pmod p$.

* для любого $x$ ($0 < x < p$) верно: $x \cdot a \not\equiv 0 \pmod p$. Потому что $x$ и $a$ взаимно просты с $p$, а значит их произведение тоже взаимно просто с $p$.

* для любых $x, y$ ($0 < x < y < p$) верно $x \cdot a \not\equiv y \cdot a \pmod p$. Перенесём правую часть в лево и переставим местами: $y \cdot a - x \cdot a \not\equiv 0 \pmod p$. Сгруппируем: $(y - x) \cdot a \not\equiv 0 \pmod p$. $a$ взаимно просто с $p$ и $y - x$ взаимно просто с $p$ (т.к. $y - x \neq 0$ и $y - x < p$), а значит действительно не обнуляется.

Из двух перечислнных пунктов следует, что в правой части равенства все $p - 1$ множителей различны и лежат на отрезке $[1, p - 1]$. Получается, в правой части на самом деле перестановка множителей из левой части. Вынесем общий множитель в правой части:

$1 \cdot 2 \cdot \ldots \cdot (p-1) \equiv a^{p-1} \cdot 1 \cdot 2 \cdot \ldots \cdot (p-1)\pmod p$

И сократим все общие множители $1 \cdot 2 \cdot \ldots \cdot (p - 1)$ (можем, т.к. они взаимнопросты с $p$):

$1 \equiv a^{p-1} \pmod p$

ч.т.д.

### Следствие

Как было сказано ранее, деление как таковое не определено в модульной арифметике. Вместо него, будем домножать на обратное число. Здесь можно почуствовать что это такое, если вспомнить курс школьной алгебры, согласно которому, для любого $a \neq 0$ существует обратный элемент $b$, такой что $a \cdot b = 1$. Значит $b = \frac{1}{a} = a^{-1}$. Обратный элемент для $a$ обычно принято обозночать как $a^{-1}$. А значит, можно вместо деления на $a$ использовать умножение на $a^{-1}$.

Теперь научимся узнавать, чему равен обратный элемент для $0 < a < p$. Воспользуемся МТФ (Малой теоремой Ферма). 

$$a^{p-1} \equiv 1 \pmod p$$
$$a^{p-2} \cdot a^1 \equiv 1 \pmod p$$
$$a^{p-2} \cdot a \equiv 1 \pmod p$$

Из этого следует, что $a^{p-2}$ является обратным элементом для $a$, и обозначается как $a^{-1}$. Для нахождения обрытного элемента можно использовать быстрое возведение в степень, рассмотренное ранее.

Отметим, что данный раздел справедлив только для простого модуля, случай составного будет рассмотрен позднее.

## НОД и алгоритм Евклида (+ НОК)

По этой теме нужно прочитать [эту статью](http://e-maxx.ru/algo/euclid_algorithm).

## Расширенный алгоритм Евклида. Диофантовы уравнения

По этой теме нужно прочитать сначала [эту статью](http://e-maxx.ru/algo/extended_euclid_algorithm), а делее [эту статью](http://e-maxx.ru/algo/diofant_2_equation).

## Обратное по произвольному модулю

Если вам показалось слишком простым изучение всего выше перечисленного, то этот раздел специально для вас! Теперь мы научимся искать обратное не по простому модулю, а по произвольному! Конечно, теперь обратные будут существовать не для всех чисел больших $0$ и меньших $m$, а лишь для взаимнопростых с $m$ (почему это так, оставляется в качестве упражнения читателю).

Для начала можно ознакомится [функцией Эйелера](http://e-maxx.ru/algo/euler_function).

Поиск обратного по произвольному модулю можно [изучить тут](http://e-maxx.ru/algo/reverse_element).




