# Остовные деревья и СНМ

## Введение: Что такое остовное дерево?
**Остовное дерево (Spanning Tree)** графа — это подграф, который:
1.  Содержит все вершины исходного графа.
2.  Является деревом (связен и не имеет циклов).
3.  Имеет ровно $V-1$ ребро (где $V$ — количество вершин).

**Минимальное остовное дерево (MST — Minimum Spanning Tree)** — это остовное дерево, сумма весов ребер которого минимальна среди всех возможных остовных деревьев этого графа.

---

## 1. Система непересекающихся множеств (DSU — Disjoint Set Union)

Это структура данных, которая позволяет эффективно управлять разбиением множества элементов на непересекающиеся подмножества.

### Основные операции:
1.  **`make_set(v)`**: создает новое множество, состоящее из одного элемента $v$.
2.  **`find_set(v)`**: возвращает идентификатор множества, которому принадлежит элемент $v$ (обычно это «лидер» или «корень» множества).
3.  **`union_sets(a, b)`**: объединяет два множества, содержащих элементы $a$ и $b$.

### Реализация (Лес корневых деревьев)
Каждое множество представляется в виде дерева. Корень дерева — лидер множества. Массив `parent[i]` хранит предка вершины $i$. Если `parent[i] == i`, то $i$ — корень.

### Эвристики оптимизации
Для достижения амортизированной сложности $O(\alpha(n))$ (почти константа) необходимо использовать две эвристики:

1.  **Сжатие путей (Path Compression):**
    При выполнении `find_set(v)`, мы рекурсивно ищем корень, а затем переподвешиваем вершину $v$ и все вершины по пути *напрямую* к корню.
    ```cpp
    int parent[MAXN]; 

    int find_set(int v) {
        if (v == parent[v])
            return v;
        return parent[v] = find_set(parent[v]); // Сжатие пути
    }
    ```

2.  **Ранговая эвристика (Union by Rank/Size):**
    При объединении двух деревьев подвешиваем дерево с меньшей высотой (или размером) к дереву с большей. Это гарантирует, что высота дерева будет расти логарифмически медленно.
    ```cpp
    int rank[MAXN]; // Высота дерева (или size - размер)

    void union_sets(int a, int b) {
        a = find_set(a);
        b = find_set(b);
        if (a != b) {
            if (rank[a] < rank[b])
                std::swap(a, b);
            parent[b] = a; // b подвешиваем к a
            if (rank[a] == rank[b])
                rank[a]++;
        }
    }
    ```

**Сложность:** $O(\alpha(n))$, где $\alpha$ — обратная функция Аккермана. Для любых практических значений $n$ ($n < 10^{600}$) $\alpha(n) \le 4$. То есть работает за константное время.

---

## 2. Алгоритм Крускала (Kruskal’s Algorithm)

Жадный алгоритм для поиска MST. Основан на сортировке ребер.

### Идея:
1.  Рассматриваем все ребра графа.
2.  Сортируем их по возрастанию веса.
3.  Перебираем ребра от самых легких к тяжелым.
4.  Если текущее ребро $(u, v)$ соединяет вершины из *разных* компонент связности (проверяем через DSU), то добавляем его в остов и объединяем компоненты. Если они уже в одной компоненте — пропускаем (иначе образуется цикл).

### Реализация (C++):
```cpp
struct Edge {
    int u, v, weight;
    bool operator<(const Edge& other) const {
        return weight < other.weight;
    }
};

vector<Edge> edges; // Все ребра графа
int cost = 0;       // Вес MST
vector<Edge> result; // Ребра MST

// ... инициализация DSU ...

sort(edges.begin(), edges.end());

for (Edge e : edges) {
    if (find_set(e.u) != find_set(e.v)) {
        cost += e.weight;
        result.push_back(e);
        union_sets(e.u, e.v);
    }
}
```

### Сложность:
*   Сортировка ребер: $O(E \log E)$ или $O(E \log V)$.
*   Операции DSU: $O(E \cdot \alpha(V)) \approx O(E)$.
*   **Итого:** $O(E \log E)$.
*   **Применение:** Отлично подходит для разреженных графов (где $E \approx V$).

---

## 3. Алгоритм Прима (Prim’s Algorithm)

Жадный алгоритм, напоминающий алгоритм Дейкстры. Мы «выращиваем» дерево из одной начальной вершины.

### Идея:
1.  Начинаем с произвольной вершины.
2.  На каждом шаге ищем ребро с **минимальным весом**, которое соединяет вершину, *уже включенную* в остов, с вершиной, *еще не включенной* в остов.
3.  Добавляем это ребро и новую вершину в остов.
4.  Повторяем, пока не включим все вершины.

### Реализация 1: Для плотных графов ($O(V^2)$)
Используем массивы `min_e[v]` (минимальное ребро из остова в $v$) и `visited[v]`. Не используем `set` или `priority_queue`.

```cpp
const int INF = 1e9;
// g[u][v] - матрица смежности или весов
int min_e[MAXN]; // Вес мин. ребра до i-й вершины из остова
bool visited[MAXN]; // Включена ли вершина в остов
int sel_e[MAXN]; // Из какой вершины пришли (для восстановления ответа)

void prim_dense(int n) {
    fill(min_e, min_e + n, INF);
    fill(visited, visited + n, false);
    min_e[0] = 0; 
    
    for (int i = 0; i < n; ++i) {
        int v = -1;
        // Ищем не посещенную вершину с минимальным min_e
        for (int j = 0; j < n; ++j) {
            if (!visited[j] && (v == -1 || min_e[j] < min_e[v]))
                v = j;
        }
        
        if (min_e[v] == INF) {
            // Граф несвязен
            break; 
        }

        visited[v] = true;
        // Релаксация соседей
        for (int to = 0; to < n; ++to) {
            // Если есть ребро (v, to) и to не в остове
            if (adj[v][to] < INF && !visited[to]) {
                if (adj[v][to] < min_e[to]) {
                    min_e[to] = adj[v][to];
                    sel_e[to] = v;
                }
            }
        }
    }
}
```

### Реализация 2: Для разреженных графов ($O(E \log V)$)
Используем `std::priority_queue` (или `set`) для хранения пар `(вес, вершина)`. Аналог Дейкстры.

```cpp
void prim_sparse(int n, vector<vector<pair<int,int>>>& adj) {
    priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> q;
    vector<int> min_e(n, INF);
    vector<bool> visited(n, false);

    min_e[0] = 0;
    q.push({0, 0});

    while (!q.empty()) {
        int v = q.top().second;
        int cur_w = q.top().first;
        q.pop();

        if (visited[v]) continue; // Ленивое удаление
        visited[v] = true;

        for (auto edge : adj[v]) {
            int to = edge.first;
            int len = edge.second;
            if (!visited[to] && len < min_e[to]) {
                min_e[to] = len;
                q.push({min_e[to], to});
            }
        }
    }
}
```

---

## Сравнение алгоритмов

| Характеристика | Алгоритм Крускала | Алгоритм Прима (обычный) | Алгоритм Прима ($O(V^2)$) |
| :--- | :--- | :--- | :--- |
| **Сложность** | $O(E \log E)$ | $O(E \log V)$ | $O(V^2)$ |
| **Структуры данных** | DSU, сортировка | Priority Queue / Set | Массивы |
| **Тип графа** | Разреженный ($E \ll V^2$) | Разреженный | Плотный ($E \approx V^2$) |
| **Сложность реализации** | Низкая | Средняя | Низкая |

### Когда что использовать на олимпиаде?
1.  **Крускал:** Используйте по умолчанию. Легко писать, сложно ошибиться. Идеален, если список ребер уже дан на входе.
2.  **Прим ($O(V^2)$):** Используйте, если граф задан матрицей смежности или количество вершин $V \le 2000$, а ребер очень много (плотный граф). Здесь Крускал с сортировкой упадет по времени.
3.  **Прим ($O(E \log V)$):** Используется редко, так как Крускал делает то же самое, но писать его проще.

## Типичные задачи на эту тему
1.  **Прямой поиск MST:** «Соединить города кабелями минимальной стоимости».
2.  **Максимальное остовное дерево:** То же самое, но сортируем ребра по убыванию (или меняем знаки весов).
3.  **Минимаксные пути:** Найти путь между $A$ и $B$, где вес *самого тяжелого ребра* на пути минимален. (Решение: это путь по MST).
4.  **Второй лучший остов:** Найти остов, следующий по стоимости после минимального (замена одного ребра в MST).