# Бор (Trie) и Алгоритм Ахо-Корасика

## 1. Строковый бор (Trie / Префиксное дерево)

**Бор** — это корневое дерево, где каждое ребро помечено символом. Путь от корня до некоторой вершины соответствует префиксу одной или нескольких строк из множества.

### Свойства:
1.  Корень соответствует пустой строке.
2.  Каждая вершина имеет до $|\Sigma|$ детей (где $|\Sigma|$ — размер алфавита, обычно 26 для латиницы).
3.  Вершины могут иметь флаг `is_terminal` (или `count`), указывающий, что здесь заканчивается слово.
4.  Общий префикс для нескольких слов хранится в памяти один раз (экономия памяти для похожих слов).

### Реализация (Статическая на массивах)
В олимпиадном программировании чаще используют массивы, а не указатели, для скорости и простоты очистки.

```cpp
const int ALPHABET = 26;
const int MAXN = 100005; // Суммарная длина всех строк

struct Trie {
    struct Node {
        int next[ALPHABET]; // Индексы детей
        bool is_terminal;   // Является ли концом слова
        // int count;       // Сколько слов проходит через вершину (опционально)
        
        Node() {
            fill(next, next + ALPHABET, -1);
            is_terminal = false;
        }
    } t[MAXN];

    int sz = 1; // Текущее кол-во вершин (0 - корень)

    void init() {
        t[0] = Node();
        sz = 1;
    }

    // Вставка строки
    void insert(const string& s) {
        int v = 0; // Начинаем с корня
        for (char c : s) {
            int idx = c - 'a';
            if (t[v].next[idx] == -1) {
                t[sz] = Node(); // Создаем новую вершину
                t[v].next[idx] = sz++;
            }
            v = t[v].next[idx];
        }
        t[v].is_terminal = true;
    }

    // Поиск строки (true, если слово есть целиком)
    bool search(const string& s) {
        int v = 0;
        for (char c : s) {
            int idx = c - 'a';
            if (t[v].next[idx] == -1) return false;
            v = t[v].next[idx];
        }
        return t[v].is_terminal;
    }
};
```

### Сложность:
*   **Память:** $O(\sum |S_i| \cdot |\Sigma|)$.
*   **Вставка/Поиск:** $O(|S|)$, где $|S|$ — длина строки.

---

## 2. Цифровой бор (Digital Trie / Бинарный бор)

Специальный вид бора для работы с числами в двоичном представлении. Используется для задач на XOR (побитовое исключающее ИЛИ).

### Особенности:
*   Алфавит состоит всего из двух символов: `0` и `1`.
*   Глубина дерева фиксирована (обычно 30 или 60 бит).
*   Числа добавляются как строки из битов (от старшего к младшему).

### Типичная задача: Максимальный XOR
*Дано множество чисел $A$. Для числа $x$ найти такое $a \in A$, чтобы $x \oplus a$ было максимальным.*

**Алгоритм:**
1.  Построить бор из всех чисел множества $A$.
2.  Для запроса $x$ идем от старшего бита к младшему.
3.  **Жадная стратегия:** Если текущий бит у $x$ равен `b`, мы хотим пойти в ветку `!b` (так как $0 \oplus 1 = 1$, мы максимизируем результат).
    *   Если ветка `!b` существует — идем туда, к ответу добавляем $(1 \ll i)$.
    *   Если нет — вынуждены идти в ветку `b`.

### Реализация (сниппет)
```cpp
struct BinaryTrie {
    int next[MAXN * 30][2]; // [вершина][бит]
    int sz = 1;

    BinaryTrie() { memset(next, -1, sizeof(next)); }

    void insert(int x) {
        int v = 0;
        for (int i = 29; i >= 0; --i) {
            int bit = (x >> i) & 1;
            if (next[v][bit] == -1) {
                memset(next[sz], -1, sizeof(next[sz]));
                next[v][bit] = sz++;
            }
            v = next[v][bit];
        }
    }

    int get_max_xor(int x) {
        int v = 0;
        int res = 0;
        for (int i = 29; i >= 0; --i) {
            int bit = (x >> i) & 1;
            // Хотим пойти в противоположный бит
            if (next[v][1 - bit] != -1) {
                res |= (1 << i);
                v = next[v][1 - bit];
            } else {
                v = next[v][bit];
            }
        }
        return res;
    }
};
```

---

## 3. Алгоритм Ахо-Корасика

Обобщение алгоритма Кнута-Морриса-Пратта (КМП) для поиска **множества** подстрок в тексте одновременно.
По сути: **Бор + Суффиксные ссылки**.

### Основные понятия:
1.  **Бор:** Строится из всех образцов (паттернов).
2.  **Суффиксная ссылка (`link`):** Ведет из вершины $u$ в вершину $v$, которая соответствует **наибольшему собственному суффиксу** строки $u$, присутствующему в боре.
    *   *Пример:* Если в боре есть пути "ABCD" и "BCD", то суфф. ссылка из "ABCD" ведет в "BCD". Если "BCD" нет, но есть "CD", то туда. Если ничего нет — в корень.
3.  **Автомат переходов (`go`):** Функция перехода. `go(u, c)` говорит, в какое состояние мы перейдем из $u$ по символу $c$. Если ребро есть в боре — идем по нему. Если нет — идем по суффиксной ссылке: `go(u, c) = go(link[u], c)`.

### Алгоритм построения:
1.  Строим обычный бор из всех паттернов.
2.  Обходим бор в ширину (BFS) для построения ссылок (так как ссылка всегда ведет в вершину с меньшей глубиной).
3.  **Ленивая динамика (или прекальк):**
    *   `link[root] = root`.
    *   Для ребенка `v` вершины `u` по символу `c`: `link[v] = go(link[u], c)`.
    *   Таблица переходов `go[u][c]` достраивается: если ребра нет, копируем значение из `go[link[u]][c]`.

### Сжатые суффиксные ссылки (Terminal Link / Up)
Иногда суффиксная ссылка ведет в вершину, которая не является концом слова. Чтобы быстро находить вхождения, используют «сжатую» ссылку `up[u]`, которая ведет к **ближайшей терминальной вершине** по цепочке суффиксных ссылок.

### Реализация

```cpp
const int K = 26; // Размер алфавита
const int N = 100005; // Суммарная длина паттернов

struct AhoCorasick {
    // Бор
    int next[N][K];      // Переходы по бору (реальные ребра)
    int go[N][K];        // Автомат (мемоизация переходов)
    int link[N];         // Суффиксные ссылки
    int up[N];           // Сжатая ссылка на ближайший терминал
    bool term[N];        // Флаг конца слова
    int sz = 1;          // Кол-во вершин

    AhoCorasick() {
        memset(next, -1, sizeof(next));
        memset(go, -1, sizeof(go));
        memset(link, 0, sizeof(link)); // link[0] = 0
        memset(up, 0, sizeof(up));
        memset(term, false, sizeof(term));
    }

    void insert(const string& s) {
        int v = 0;
        for (char c : s) {
            int c_idx = c - 'a';
            if (next[v][c_idx] == -1) {
                next[v][c_idx] = sz++;
            }
            v = next[v][c_idx];
        }
        term[v] = true;
    }

    // Построение автомата (BFS)
    void build() {
        queue<int> q;
        
        // Инициализация 0-го уровня (дети корня)
        for (int i = 0; i < K; ++i) {
            if (next[0][i] != -1) {
                q.push(next[0][i]);
                // link[child] = 0 (уже 0 по умолчанию)
                // go[0][i] выставится в цикле bfs или нужно явно
            } else {
                next[0][i] = 0; // Для удобства автомата: нет ребра -> идем в корень
            }
        }

        while (!q.empty()) {
            int u = q.front();
            q.pop();

            // Вычисляем up[u]
            if (term[link[u]]) up[u] = link[u];
            else up[u] = up[link[u]];

            for (int c = 0; c < K; ++c) {
                if (next[u][c] != -1) {
                    int v = next[u][c];
                    // Ссылка v ведет туда, куда ведет u по c
                    link[v] = next[link[u]][c]; // Важно: тут используем уже вычисленный next[link] как go
                    q.push(v);
                } else {
                    // Эвристика: подменяем next на переход по суфф. ссылке
                    // Это превращает next в go
                    next[u][c] = next[link[u]][c];
                }
            }
        }
    }

    // Пример использования: поиск всех вхождений в текст T
    void search(const string& t) {
        int v = 0;
        for (int i = 0; i < t.size(); ++i) {
            v = next[v][t[i] - 'a']; // Переход за O(1)
            
            // Проверка терминалов
            int temp = v;
            while (temp > 0) {
                if (term[temp]) {
                    // Нашли паттерн, заканчивающийся в позиции i
                    // cout << "Found at " << i << endl;
                }
                temp = up[temp]; // Прыгаем сразу к следующему слову
                // Если up не используется, то temp = link[temp], но это медленнее O(N) -> O(sqrt N)
            }
        }
    }
};
```
*(Примечание: В реализации выше массив `next` после `build` начинает работать как `go`, что экономит память).*

### Применение и задачи:
1.  **Поиск словаря в тексте:** Дано $N$ слов и текст $T$. Найти количество вхождений каждого слова. Сложность: $O(|T| + \sum |S_i|)$.
2.  **Вирусы:** Есть набор запрещенных слов (вирусов). Может ли бесконечная строка не содержать вирусов? (Поиск цикла в графе Ахо-Корасика, недостижимого из терминальных вершин).
3.  **Динамика по Ахо-Корасика:** Построить строку длины $L$, удовлетворяющую условиям. Состояние ДП: `dp[len][node_in_trie]`.
4.  **Количество различных подстрок:** Можно решать суффиксным автоматом, но иногда используют бор (если строк немного).

---

## Резюме для запоминания

| Структура | Суть | Сложность | Главное применение |
| :--- | :--- | :--- | :--- |
| **Trie (Бор)** | Дерево префиксов | $O(|S|)$ | Словарь, автодополнение, сортировка строк |
| **Digital Trie** | Бор на битах (0/1) | $O(\log C)$ | XOR-максимизация, задачи на биты |
| **Aho-Corasick** | Бор + КМП (суфф. ссылки) | $O(|T|)$ | Поиск множества паттернов, DP на строках |