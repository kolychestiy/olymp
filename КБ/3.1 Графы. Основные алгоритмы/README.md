# Графы. Основные алгоритмы

**Базовое понятие:** DFS (Depth First Search) — обход в глубину.
**Сложность всех алгоритмов:** $O(V + E)$, где $V$ — количество вершин, $E$ — количество ребер.

---

## 1. Топологическая сортировка

**Применимость:** Только для **ориентированных графов без циклов** (DAG — Directed Acyclic Graph).
**Суть:** Упорядочить вершины в линейный список так, что для любого ребра $u \to v$, вершина $u$ идет в списке раньше, чем $v$.

### Алгоритм
Используем DFS. Идея в том, что вершина должна быть добавлена в топологический порядок только после того, как будут обработаны все вершины, в которые из нее можно попасть.

1. Запускаем `dfs(v)` для всех непосещенных вершин.
2. В конце функции `dfs(v)` (перед выходом) добавляем вершину $v$ в конец списка `order`.
3. После обхода всего графа, полученный список `order` нужно **развернуть** (reverse).

### Реализация (C++)
```cpp
vector<int> g[MAXN];
bool visited[MAXN];
vector<int> order;

void dfs(int v) {
    visited[v] = true;
    for (int to : g[v]) {
        if (!visited[to]) {
            dfs(to);
        }
    }
    order.push_back(v); // Добавляем при выходе
}

void topological_sort() {
    for (int i = 0; i < n; ++i) visited[i] = false;
    order.clear();
    for (int i = 0; i < n; ++i) {
        if (!visited[i]) dfs(i);
    }
    reverse(order.begin(), order.end());
}
```

---

## 2. Поиск цикла

### А) В неориентированном графе
**Признак цикла:** Если в DFS мы видим ребро, ведущее в уже посещенную вершину, и эта вершина **не является прямым предком** (откуда мы пришли), то цикл найден.

### Б) В ориентированном графе
Здесь сложнее. Используем **раскраску вершин** (3 цвета):
*   `0` (White): Вершина не посещена.
*   `1` (Gray): Мы вошли в вершину, но еще не вышли (вершина в стеке рекурсии).
*   `2` (Black): Вершина полностью обработана.

**Признак цикла:** Если в DFS мы пытаемся пойти в вершину цвета `1` (серую), значит, мы нашли «обратное ребро» и цикл существует.

### Реализация (Ориентированный граф + восстановление пути)
```cpp
int color[MAXN]; // 0, 1, 2
int parent[MAXN];
int cycle_start = -1, cycle_end;

bool dfs(int v) {
    color[v] = 1; // Красим в серый
    for (int to : g[v]) {
        if (color[to] == 0) {
            parent[to] = v;
            if (dfs(to)) return true;
        } else if (color[to] == 1) {
            // Нашли цикл
            cycle_end = v;
            cycle_start = to;
            return true;
        }
    }
    color[v] = 2; // Красим в черный
    return false;
}

// Восстановление: идем от cycle_end по parent до cycle_start
```

---

## 3. Поиск мостов (Bridges)

**Определение:** Ребро является мостом, если его удаление увеличивает количество компонент связности.
**Применимость:** Неориентированные графы.

### Алгоритм (Метод времени входа)
Используем два массива:
1.  `tin[v]` (time in) — время входа в вершину при DFS.
2.  `up[v]` (ret, fup) — минимальное время `tin`, до которого можно добраться из вершины $v$ (и её поддерева в DFS), пройдя по обратному ребру **не более одного раза**.

**Правило вычисления `up[v]`:**
`up[v] = min(`
  `tin[v]`,
  `tin[p]` — для всех обратных ребер $(v, p)$,
  `up[to]` — для всех прямых ребер в дереве DFS $(v, to)$
`)`

**Условие моста:** Ребро $(v, to)$ — мост, если **`up[to] > tin[v]`**.
*Интуиция:* Из поддерева `to` нет обратного ребра, которое ведет в `v` или выше `v`.

### Реализация
```cpp
int tin[MAXN], up[MAXN];
int timer;
vector<pair<int, int>> bridges; // {u, v}

void dfs(int v, int p = -1) {
    visited[v] = true;
    tin[v] = up[v] = timer++;
    
    for (int to : g[v]) {
        if (to == p) continue; // Не идем назад к родителю
        if (visited[to]) {
            // Обратное ребро
            up[v] = min(up[v], tin[to]);
        } else {
            // Прямое ребро
            dfs(to, v);
            up[v] = min(up[v], up[to]);
            if (up[to] > tin[v]) {
                bridges.push_back({v, to});
            }
        }
    }
}
```
*Важно:* Если есть кратные ребра, проверка `to == p` некорректна (нужно передавать ID ребра).

---

## 4. Поиск точек сочленения (Cut Vertices)

**Определение:** Вершина, при удалении которой увеличивается количество компонент связности.

### Алгоритм
Похож на поиск мостов, используются те же `tin` и `up`.

**Условия:**
1.  **Если $v$ — корень дерева DFS:** Она является точкой сочленения тогда и только тогда, когда у нее в дереве DFS **более одного ребенка** (вызовов `dfs` из нее > 1).
2.  **Если $v$ — не корень:** Она является точкой сочленения, если у нее есть такой ребенок `to`, что **`up[to] >= tin[v]`**.
    *Интуиция:* Из поддерева ребенка `to` нельзя подняться выше `v` (в обход `v`).

### Реализация
```cpp
set<int> cut_points; // Используем set, чтобы избежать дублей

void dfs(int v, int p = -1) {
    visited[v] = true;
    tin[v] = up[v] = timer++;
    int children = 0;
    
    for (int to : g[v]) {
        if (to == p) continue;
        if (visited[to]) {
            up[v] = min(up[v], tin[to]);
        } else {
            dfs(to, v);
            up[v] = min(up[v], up[to]);
            if (up[to] >= tin[v] && p != -1) {
                cut_points.insert(v);
            }
            children++;
        }
    }
    // Отдельная проверка для корня
    if (p == -1 && children > 1) {
        cut_points.insert(v);
    }
}
```

---

## 5. Поиск компонент сильной связности (SCC)

**Определение:** В ориентированном графе компонента сильной связности — это максимальное множество вершин, где из любой вершины можно добраться до любой другой внутри множества.

Самый популярный и простой для запоминания алгоритм — **Алгоритм Косарайю (Kosaraju)**.

### Алгоритм Косарайю
Состоит из двух этапов DFS:

1.  **Этап 1 (Построение порядка выхода):**
    Запускаем DFS на исходном графе $G$. Запоминаем вершины в порядке выхода (как в топологической сортировке), записываем в список `order`.
2.  **Этап 2 (Инверсия и поиск):**
    Строим транспонированный граф $G^T$ (все ребра развернуты в обратную сторону).
    Идем по списку `order` с конца (от самой "поздней" вершины). Если вершина не посещена, запускаем DFS уже на графе $G^T$.
    Все вершины, которые обойдет этот DFS, образуют одну **компоненту сильной связности**.

### Реализация
```cpp
vector<int> g[MAXN], gr[MAXN]; // g - исходный, gr - транспонированный
vector<int> order, component;
bool visited[MAXN];

void dfs1(int v) {
    visited[v] = true;
    for (int to : g[v]) if (!visited[to]) dfs1(to);
    order.push_back(v);
}

void dfs2(int v) {
    visited[v] = true;
    component.push_back(v);
    for (int to : gr[v]) if (!visited[to]) dfs2(to);
}

void find_scc() {
    // 1. Заполняем order
    memset(visited, 0, sizeof(visited));
    for (int i = 0; i < n; ++i) if (!visited[i]) dfs1(i);
    
    // 2. Ищем компоненты в обратном графе
    memset(visited, 0, sizeof(visited));
    reverse(order.begin(), order.end()); // Идем с конца
    
    for (int v : order) {
        if (!visited[v]) {
            dfs2(v);
            // component содержит текущую SCC, обрабатываем её
            component.clear();
        }
    }
}
```

---

### Сводная таблица (Шпаргалка)

| Алгоритм | Граф | Ключевая идея | Условие |
| :--- | :--- | :--- | :--- |
| **Топ. сорт** | Ориент. (DAG) | DFS + порядок выхода | `order.push_back` после обработки детей |
| **Цикл** | Любой | Обратное ребро | Серый цвет (ориент) или посещенный не родитель (неориент) |
| **Мосты** | Неориент. | `tin`, `up` | `up[to] > tin[v]` |
| **Точки сочл.**| Неориент. | `tin`, `up` | `up[to] >= tin[v]` (не корень) или `children > 1` (корень) |
| **SCC** | Ориент. | Kosaraju ($G + G^T$) | DFS(G) $\to$ Reverse order $\to$ DFS($G^T$) |