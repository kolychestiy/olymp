# Переборы. Стресс-тестирование. Интерактивные задачи

## 1. Рекурсивные переборы (Backtracking)

**Суть метода:**
Полный перебор всех возможных вариантов решения с целью найти подходящее или оптимальное. Чаще всего реализуется рекурсивно.
Если мы зашли в тупик (текущая ветка перебора не может дать ответ), мы возвращаемся назад (**backtrack**) и выбираем другой вариант.

**Применимость:**
Ограничения $N \le 20$ (сложность $O(2^N)$) или $N \le 10..11$ (сложность $O(N!)$).

### Общая схема (Шаблон)
```cpp
void solve(int index, CurrentState& state) {
    // 1. База рекурсии: решение найдено или дошли до конца
    if (index == n) {
        check_and_update_answer(state);
        return;
    }

    // 2. Перебор кандидатов для текущего шага
    for (auto candidate : possible_moves) {
        // 3. Отсечение (Pruning): если шаг заведомо плохой — пропускаем
        if (!is_valid(candidate, state)) continue; 

        // 4. Применяем ход
        state.add(candidate);
        
        // 5. Рекурсивный вызов
        solve(index + 1, state);
        
        // 6. Бэк-трекинг (откат изменений)
        state.remove(candidate);
    }
}
```

### Важные техники:
1.  **Отсечения (Pruning):** Прерывание ветки рекурсии как можно раньше, если очевидно, что она не приведет к оптимальному ответу (например, текущая сумма уже больше найденного минимума).
2.  **Битовые маски:** Часто используются для хранения состояния «какие элементы выбраны» (вместо `vector<bool>`).
3.  **Meet-in-the-middle:** Если $N=40$, перебор $2^{40}$ не зайдет. Разбиваем задачу на две части по $N=20$. Генерируем варианты для первой половины, сохраняем в Map/Set, затем генерируем вторую и ищем пару.

---

## 2. Аспекты стресс-тестирования

**Проблема:** Решение проходит претесты, но получает WA (Wrong Answer) на основном тестировании, и вы не можете найти ошибку глазами.
**Решение:** Написать генератор случайных тестов и сравнить ответы вашего решения с заведомо правильным (но медленным) решением.

### Компоненты стресс-теста:
1.  **Solution (Main):** Ваше быстрое, оптимизированное решение (предположительно с багом).
2.  **Stupid (Naive):** Медленное, «тупое», но гарантированно верное решение (полный перебор, симуляция).
3.  **Generator:** Программа, создающая случайный тест в формате задачи.
4.  **Script:** Скрипт, который крутит цикл запуска.

### Реализация Генератора (C++)
Используйте `mt19937` для качественного рандома.
```cpp
#include <iostream>
#include <random>

using namespace std;

int main(int argc, char* argv[]) {
    // seed передается параметром, чтобы каждый тест был разным
    int seed = atoi(argv[1]); 
    mt19937 rng(seed);
    
    int n = rng() % 10 + 1; // Небольшие N (чтобы Stupid работал быстро)
    cout << n << endl;
    for (int i = 0; i < n; ++i) {
        cout << (rng() % 100) << " ";
    }
    cout << endl;
}
```

### Скрипт запуска (Windows .bat или Linux .sh)
Пример псевдокода логики скрипта:
```bash
for ((i=1; ; i++)); do
    ./generator $i > input.txt
    ./stupid < input.txt > correct.txt
    ./solution < input.txt > my.txt
    
    # Сравниваем файлы (diff в Linux, fc в Windows)
    diff my.txt correct.txt || break
    echo "Test $i: OK"
done
echo "WA found on input.txt"
```

**Советы:**
*   Генерируйте **маленькие** тесты. Найти ошибку на массиве из 5 чисел проще, чем на 100 000.
*   Не забывайте про **крайние случаи** (N=1, граф-линия, граф-звезда, все числа одинаковые).

---

## 3. Аспекты интерактивных задач

**Суть:** В интерактивных задачах ввод не дан сразу. Ваша программа обменивается сообщениями с программой жюри (интерактором). Вы задаете «вопрос» (вывод в `stdout`), жюри дает «ответ» (ввод из `stdin`).

### Особенности ввода/вывода
Главное правило: **СБРОС БУФЕРА (FLUSH)**.
После каждого вывода запроса данные могут застрять в буфере вывода вашей программы. Жюри их не увидит и будет ждать вечно $\to$ `Idleness Limit Exceeded`.

**Как делать flush:**
*   **C++:** `cout << endl;` (вместо `\n`) или `fflush(stdout);`
*   **Python:** `print(..., flush=True)` или `sys.stdout.flush()`
*   **Java:** `System.out.flush()`

### Ограничения
Обычно ограничено количество запросов (например, не более 100 вопросов).
Это намекает на сложность:
*   $\approx 100$ запросов $\to$ Линейный поиск или что-то простое.
*   $\approx 20-30$ запросов $\to$ Бинарный поиск ($\log 10^9 \approx 30$).
*   $\approx 2$ запроса $\to$ Математическая формула.

### Пример (Угадать число от 1 до 100):
```cpp
int l = 1, r = 100;
while (l != r) {
    int mid = (l + r + 1) / 2;
    cout << "? " << mid << endl; // Запрос с flush
    
    string response;
    cin >> response;
    if (response == ">=") l = mid;
    else r = mid - 1;
}
cout << "! " << l << endl; // Ответ
```

---

## 4. Методы тестирования интерактивных задач

Тестировать интерактив сложно, так как нельзя просто подать файл `input.txt`. Есть три подхода:

### А. Локальная заглушка (Stub) внутри кода
Самый простой способ. Вы пишете функцию `query`, которая имитирует поведение жюри.

```cpp
// #define LOCAL // Раскомментировать для тестов дома

int HIDDEN_X = 42; // Секретное число для теста

int query(int val) {
#ifdef LOCAL
    // Локальная логика
    if (val <= HIDDEN_X) return 1;
    else return 0;
#else
    // Реальная отправка
    cout << "? " << val << endl;
    int ans; cin >> ans;
    return ans;
#endif
}

void solve() {
    // Используем query() вместо прямых cin/cout
}
```

### Б. Ручное тестирование
Вы запускаете свою программу. Она печатает вопрос. Вы (человек) смотрите на вопрос, придумываете ответ и вводите его с клавиатуры.
*Минус:* Долго, легко ошибиться самому.

### В. Скрипт-интерактор (Python)
Профессиональный подход. Пишем скрипт на Python, который запускает ваше решение как подпроцесс и общается с ним через пайпы (pipes).

**Пример `test_runner.py`:**
```python
import subprocess
import sys

# Скрытое значение для теста
SECRET = 50

# Запуск скомпилированного решения (main.exe или ./main)
process = subprocess.Popen(
    ['./main'], 
    stdin=subprocess.PIPE, 
    stdout=subprocess.PIPE, 
    text=True // Работаем со строками, а не байтами
)

while True:
    # Читаем строку от вашего решения
    line = process.stdout.readline()
    if not line: break
    line = line.strip()
    
    if line.startswith("!"):
        print(f"Solution guessed: {line}")
        break
        
    if line.startswith("?"):
        val = int(line.split()[1])
        # Логика жюри
        response = ">=" if SECRET >= val else "<"
        
        # Пишем ответ решению
        process.stdin.write(response + "\n")
        process.stdin.flush()
```
Запускаем `python test_runner.py`. Если работает корректно — можно сдавать.

---

### Резюме (Шпаргалка)

| Тема | Ключевые моменты |
| :--- | :--- |
| **Рекурсия** | База, шаг, откат (backtrack), отсечение (pruning). |
| **Стресс-тест** | `Solution` vs `Stupid`, генератор случайных тестов, скрипт сравнения. Тесты должны быть маленькими. |
| **Интерактив** | Всегда делай `cout << endl`. Следи за лимитом вопросов. |
| **Тест Интерактива** | `#ifdef LOCAL` с подменой функции запроса или Python-скрипт с `subprocess`. |