# Переборы. Стресс-тестирование. Интерактивные задачи

## 1. Переборы

**Суть метода:**
Полный перебор всех возможных вариантов решения с целью найти подходящее или оптимальное. Чаще всего реализуется рекурсивно.
Если мы зашли в тупик (текущая ветка перебора не может дать ответ), мы возвращаемся назад (**backtrack**) и выбираем другой вариант.

**Грубые оценки времени работы:**
Ограничения $N \le 20..30$ (сложность $O(2^N)$) или $N \le 10..12$ (сложность $O(N!)$) и т.п.

Примеры задач: Генерация всех перестановок длины $n$, Перебор всех сочетаний из $n$ по $k$, Перебор всех подмножеств $n$ элементного множества, Поиск лучшего хода в игре (крестики-нолики, шахматы) и т.д.

### Общая схема (Шаблон)
```cpp
void solve(int index, CurrentState& state) {
    // 1. База рекурсии: решение найдено или дошли до конца
    if (index == n) {
        check_and_update_answer(state);
        return;
    }

    // 2. Перебор кандидатов для текущего шага
    for (auto candidate : possible_moves) {
        // 3. Отсечение (Pruning): если шаг заведомо плохой — пропускаем
        if (!is_valid(candidate, state)) continue; 

        // 4. Применяем ход
        state.add(candidate);
        
        // 5. Рекурсивный вызов
        solve(index + 1, state);
        
        // 6. Бэк-трекинг (откат изменений)
        state.remove(candidate);
    }
}
```

### Примеры задач

#### Перебор сочетаний

Пусть есть $n$ предметов с весами $a_0, a_1, \ldots, a_{n-1}$ и $a_i \ge 0$. Нужно найти такие $k$ предметов, что их сумма весов больше $S$, но при этом сумма весов минимально возможная.

```cpp
int best_sum = INF; // число заведомо большее чем k * max_ai
vector<int> v_ans;
vector<int> v_cur;
// мы можем брать предметы с индексами только не меньше i
void f(int i, int cur_sum) {
    // отсекаем, если сумма уже достигла значения для какого-то 
    // потенциального ответа (используя неотрицательность ai)
    if (cur_sum >= best_sum) { 
        return;
    }
    if (v_cur.size() == k) {
        best_sum = cur_sum;
        v_ans = v_cur;
        return;
    }

    // если взяв все предметы с индексами не меньше j мы всё ещё
    // не доберём k - нет смысла продолжать такую рекурсию
    for (int j = i; n - j <= k - v_cur.size(); j++) {
        v_cur.push_back(j);
        f(j, cur_sum + a[j]);
        v_cur.pop_back();
    }
}
```

#### Перебор перестановок

Можно реализовать рекурсивно (и иногда полезно для скорости работы).

Здесь же мы рассмотрим пример функции, которая принимая на вход перестановку (или просто произвольный массив), будет выдавать следующую лексикографическую перестановку данных элементов.

Пусть есть массив `a`.

1. Идём справа налево и ищем **первый индекс `i`**, где `a[i] < a[i+1]`.
   Это “перелом” (pivot).
   Если такого `i` нет — массив невозрастающий, значит он максимальный → сброс и `false`.

2. Идём снова справа налево и ищем **самый правый элемент `a[j]`**, такой что `a[j] > a[i]`.

3. Меняем `a[i]` и `a[j]`.

4. **Разворачиваем суффикс** `a[i+1..n)` (он был невозрастающим, после swap его надо сделать минимальным).

Сложность: `O(n)` на один вызов.

В $C++$ же есть встроенные методы для перебора перестановок, такие как `next_permutation` и `prev_permutation` (работающие на описанном выше принципе).

`next_permutation` — это стандартная функция C++, которая **переставляет элементы диапазона в следующую лексикографическую перестановку** и возвращает `true`, если такая перестановка существует. Если текущая перестановка была **последней** (максимальной), то функция **переведёт диапазон в первую (минимальную)** и вернёт `false`.

##### Что значит “лексикографическая”

Как в словаре: сравниваем два массива слева направо. Массив `1 2 4 3` меньше, чем `1 3 0 0`, потому что на первом отличающемся месте `2 < 3`.

Лексикографический порядок корректно работает, если элементы сравнимы оператором `<` (или можно передать свой компаратор).

##### Пример перебора всех перестановок длины 3

```cpp
#include <bits/stdc++.h>
using namespace std;

int main() {
    vector<int> a = {1, 2, 3};

    do {
        for (int x : a) cout << x << " ";
        cout << "\n";
    } while (next_permutation(a.begin(), a.end()));
}
```

Вывод:

```
1 2 3
1 3 2
2 1 3
2 3 1
3 1 2
3 2 1
```

Ключевое: **начинать нужно с отсортированного массива**, иначе мы переберём не всё, а только “хвост” начиная с текущей перестановки.

##### Что возвращает

* `true` — успешно сделали “следующую” перестановку
* `false` — текущая была последней; диапазон сброшен в минимальную (обычно отсортирован по возрастанию)

##### Частые применения

1) Перебор всех перестановок

```cpp
sort(a.begin(), a.end());
do {
    // использовать a
} while (next_permutation(a.begin(), a.end()));
```

2) Перебор всех подмножеств размера k (комбинаций) через 0/1-маску

Очень популярный трюк:

```cpp
int n = 5, k = 2;
vector<int> mask(n, 0);
fill(mask.end() - k, mask.end(), 1); // 0 0 0 1 1

do {
    for (int i = 0; i < n; i++)
        if (mask[i]) cout << i << " ";
    cout << "\n";
} while (next_permutation(mask.begin(), mask.end()));
```

Это выдаст все комбинации индексов размера `k` (в лексикографическом порядке по маске).

##### Важные нюансы

* Если элементы **повторяются**, `next_permutation` перебирает **только уникальные** перестановки (если стартовать с `sort`).
  Пример: `1 1 2` даст 3 варианта: `112, 121, 211`.

* Есть обратная функция: `prev_permutation` — двигает в предыдущую лексикографическую.

* Можно задать свой порядок:

```cpp
next_permutation(a.begin(), a.end(), greater<int>());
```

Тогда “следующая” считается в порядке, заданном компаратором (но это редко нужно).

### Кратко про некоторые важные техники:
1.  **Отсечения (Pruning):** Прерывание ветки рекурсии как можно раньше, если очевидно, что она не приведет к оптимальному ответу (например, текущая сумма уже больше найденного минимума).
2.  **Битовые маски:** Часто используются для хранения состояния «какие элементы выбраны» (вместо `vector<bool>`).
3.  **Meet-in-the-middle:** Например нужно найти подмножество среди $N$ предметов с суммой ровно $S$. Если $N=40$, перебор $2^{40}$ не зайдет. Разбиваем массив на две части по $N=20$. Генерируем варианты для первой половины, сохраняем в Map/Set, затем генерируем вторую и ищем пару.

---

## 2. Аспекты стресс-тестирования

**Проблема:** Решение проходит претесты, но получает WA (Wrong Answer) на основном тестировании, и вы не можете найти ошибку глазами или подобрать тест "руками".
**Решение:** Написать генератор случайных тестов и сравнить ответы вашего решения с другим, скорее всего правильным но медленным, решением.

### Компоненты стресс-теста:
1.  **Solution (Main):** Ваше быстрое, оптимизированное решение (предположительно с багом).
2.  **Stupid (Naive):** Медленное, «тупое», но идейно гарантированно верное решение (полный перебор, симуляция, просто более ресурсно затратное решение). Такое решение по возможности должно писаться быстро, иначе выгодне может попробовать подобрать тест руками или аналитически искать ошибку, читая код.
3.  **Generator:** Программа, создающая случайный тест в формате задачи. В большинстве задач генерация каких-то случайных тестов не представляет большой трудности, хотя иногда это сложно.
4.  **Script:** Скрипт, который ищет тест, на котором не работает основное решение используя описанные выше компоненты.

### Реализация Генератора (C++)
Используйте `mt19937` для качественного рандома.
```cpp
#include <iostream>
#include <random>

using namespace std;

int main(int argc, char* argv[]) {
    random_device rd;         
    // в качестве сида для хорошего генератора используем сгенерированное 
    // случайное значение от не очень хорошего генератора. Можно 
    // использовать в качестве сида время, но это имеет ряд недостатков, 
    // такие как запуск в одну и ту же секунду с одинаковым сидом
    mt19937 rng(rd());
    
    int n = rng() % 10 + 1; // Небольшие N (чтобы Stupid работал быстро)
    cout << n << endl;
    for (int i = 0; i < n; ++i) {
        cout << (rng() % 100) << " ";
    }
    cout << endl;
}
```

#### Генерация деревьев

Для генерации деревьев (в том числе некорневых), можно сказать что вершина $1$ это корень, а для каждой вершины от $2$ до $n$ выбрать случайного родителя, меньше по номеру чем она сама. Так гарантируется связность графа и число рёбер $n - 1$.

```cpp
    vector<pair<int, int>> edges;
    for (int i = 2; i <= n; i++) {
        edges.push_back({i, rng() % (i - 1) + 1});
    }
    // для перемешивания массива можно воспользоваться встроенной функцией или приведённым ниже шаблоном
    for (auto& e : edges) {
        swap(e, edges[rng() % edges.size()]);
    }
    // если есть необходимость - можно перенумеровать вершины 
    // некоторые решения на изоморфных деревьях, но с разной нумерацией дают разный ответ
    vector<int> p(n);
    // заполняем значениями от 0 до n - 1
    iota(p.begin(), p.end(), 0);
    // а здесь пример встроенной функции
    shuffle(a.begin(), a.end(), rng);

    cout << n << '\n';
    for (auto [u, v] : edges) {
        cout << u << ' ' << v << '\n';
    }
```

### Скрипт запуска 

Пример скрипта на C++:

```cpp
#include<bits/stdc++.h>
using namespace std;

signed main() {

    system("g++ main.cpp -DTEST -o main");
    system("g++ stup.cpp -DTEST -o stup");
    system("g++ gen.cpp -o gen");

    while (true) {
        system("gen > input.txt");
        system("stup < input.txt > stup.out");
        system("main < input.txt > main.out");
        if (system("fc stup.out main.out")) {
            break;
        }
    }

}
```

-DTEST позволяет например в случае для задачи с несколькими ответами, во время стресс-тестирования выводить только ту информацию, что не зависит от выбранного ответа (например размер ответа):

```cpp
    // решение задачи
    #ifdef TEST
        cout << ans.size();
    #else
        cout << ans.size() << '\n';
        for (auto& e : ans) cout << e << ' ';
    #endif
```

#### Альтернатива (Windows .bat или Linux .sh)

Пример псевдокода логики скрипта:
```bash
for ((i=1; ; i++)); do
    ./generator $i > input.txt
    ./stupid < input.txt > correct.txt
    ./solution < input.txt > my.txt
    
    # Сравниваем файлы (diff в Linux, fc в Windows)
    diff my.txt correct.txt || break
    echo "Test $i: OK"
done
echo "WA found on input.txt"
```

**Советы:**
*   Генерируйте **маленькие** тесты. Найти ошибку на массиве из 5 чисел проще, чем на 100 000.
*   Однако, для проверки самой возможности нахождения ошибки с помщью наивного решения, можно сначала найти тест на больших размерах (но не долго обрабатывающихся наивным решением), и если находится, то запустить поиск на более маленьких.
*   Не забывайте про **крайние случаи** (N=1, граф-линия, граф-звезда, все числа одинаковые).

---

## 3. Аспекты интерактивных задач

**Суть:** В интерактивных задачах ввод не дан сразу. Ваша программа обменивается сообщениями с программой жюри (интерактором). Вы задаете «вопрос» (вывод в `stdout`), жюри дает «ответ» (ввод из `stdin`).

### Особенности ввода/вывода
Главное правило: **СБРОС БУФЕРА (FLUSH)**.
После каждого вывода запроса данные могут застрять в буфере вывода вашей программы. Жюри их не увидит и будет ждать вечно $\to$ `Idleness Limit Exceeded`.

**Как делать flush:**
*   **C++:** `cout << endl;` (вместо `\n`) или `fflush(stdout);`
*   **Python:** `print(..., flush=True)` или `sys.stdout.flush()`
*   **Java:** `System.out.flush()`

### Ограничения
Обычно ограничено количество запросов (например, не более 100 вопросов).
Это намекает на сложность:
*   $\approx 100$ запросов $\to$ Линейный поиск или что-то простое.
*   $\approx 20-30$ запросов $\to$ Бинарный поиск ($\log 10^9 \approx 30$).
*   $\approx 2$ запроса $\to$ Математическая формула.

### Пример (Угадать число от 1 до 100):
```cpp
int l = 1, r = 100;
while (l != r) {
    int mid = (l + r + 1) / 2;
    cout << "? " << mid << endl; // Запрос с flush
    
    string response;
    cin >> response;
    if (response == ">=") l = mid;
    else r = mid - 1;
}
cout << "! " << l << endl; // Ответ
```

Хорошим правилом для интерактивных задач является вынос логики взаимодействия с программой жюри в отдельную функцию. В примере выше это не имеет большого значения, но зачастую выводить запрос и получать ответ надо сразу в нескольких местах программы (даже если при начале написания программы кажется что будет мало, может оказаться больше). Так переделаем код выше:

```cpp
// лямба-функция
auto query = [&](int x) {
    cout << "? " << mid << endl; // Запрос с flush
    string response;
    cin >> response;
    return response == ">=";
}

int l = 1, r = 100;
while (l != r) {
    int mid = (l + r + 1) / 2;

    if (query(mid)) l = mid;
    else r = mid - 1;
}
cout << "! " << l << endl; // Ответ
```

---

## 4. Методы тестирования интерактивных задач

Тестировать интерактив сложно, так как нельзя просто подать файл `input.txt`. Есть три подхода:

### А. Локальная заглушка (Stub) внутри кода
Самый простой способ. Вы пишете функцию `query`, которая имитирует поведение жюри.

```cpp
// #define LOCAL // Раскомментировать для тестов дома

int HIDDEN_X = 42; // Секретное число для теста

int query(int val) {
#ifdef LOCAL
    // Локальная логика
    if (val <= HIDDEN_X) return 1;
    else return 0;
#else
    // Реальная отправка
    cout << "? " << val << endl;
    int ans; cin >> ans;
    return ans;
#endif
}

void solve() {
    // Используем query() вместо прямых cin/cout
}
```

При этом рекомендуется вместо комментировая `#define LOCAL` вставить её в строку компиляции, и всегда использовать при запуске локально, но при отправке в тестирующую систему такого ключа (-DLOCAL) там нет, а значит можно ничего не комментировать.

### Б. Ручное тестирование
Вы запускаете свою программу. Она печатает вопрос. Вы (человек) смотрите на вопрос, придумываете ответ и вводите его с клавиатуры.
*Минус:* Долго, легко ошибиться самому.

### В. Скрипт-интерактор (Python)
Профессиональный подход. Пишем скрипт на Python, который запускает ваше решение как подпроцесс и общается с ним через пайпы (pipes).

**Пример `test_runner.py`:**
```python
import subprocess
import sys

# Скрытое значение для теста
SECRET = 50

# Запуск скомпилированного решения (main.exe или ./main)
process = subprocess.Popen(
    ['./main'], 
    stdin=subprocess.PIPE, 
    stdout=subprocess.PIPE, 
    text=True // Работаем со строками, а не байтами
)

while True:
    # Читаем строку от вашего решения
    line = process.stdout.readline()
    if not line: break
    line = line.strip()
    
    if line.startswith("!"):
        print(f"Solution guessed: {line}")
        break
        
    if line.startswith("?"):
        val = int(line.split()[1])
        # Логика жюри
        response = ">=" if SECRET >= val else "<"
        
        # Пишем ответ решению
        process.stdin.write(response + "\n")
        process.stdin.flush()
```
Запускаем `python test_runner.py`. Если работает корректно — можно сдавать.
