# Поиск в глубину и ширину

## Основы теории графов. Определения

<img src="img\Graph.png" style="display: block; margin: auto; width: 80%; margin-bottom: 18px;" />

*Пример графа изображённого на плоскости*

> **определение** Граф $G$ это пара множеств $G = (V, E)$, где $V$ $-$ множество вершин, а $E$ $-$ множество рёбер ($E \subset \{( u, v ) : u, v \in V\}$).

Неформально это можно понимать как набор вершин (точек) и соединяющих их отрезков (рёбер). Так например, для графа с рисунка, $V = \{0, 1, 2, 3, 4, 5, 6\}$ и $E = \{ (0, 1), (0, 2), (1, 2), (1, 3), (2, 4), (2, 5), (3, 4), (4, 5), (5, 6) \}$. 

Графы имеют широкую область применения, и могут быть хорошей моделью например для задач поиска маршурта между городами/зданиями/перекрёстками и т.д. Рёбрами графа в таком случае выступают дороги, соединающие некоторые пары городов/зданий/перекрёстков. Или, например, можно представлять людей как вершины графа, и если некоторая пара людей знакома друг с дургом, проводить между ними ребро. В такой модели, [правило шести рукопожатий](https://ru.wikipedia.org/wiki/Теория_шести_рукопожатий), означает, что от любой вершины графа до любой другой, можно добраться перейдя по не более чем шести рёбрам.

> **определение** вершины $u$ и $v$ называются *смежными*, если они соединены ребром.

> **определение** *инцидентность* $-$ это для ребра $(a, b)$ вершины $a$ и $b$ называются инцидентными. И наоборот, для вершины $a$ любое ребро $(a,x)$ (или $(x,a)$) называется инцидентным данной вершине $a$.

> **определение** *степень* вершины $v$ $-$ количество инцедентных ей рёбер.

> **определение** *кратные ребра* $-$ это ребра, которые соединяют одну и ту же пару вершин. Если две вершины соединены более чем одним ребром, говорят, что граф содержит кратные ребра, или называют такой граф мультиграфом.

> **Определение** *петля* $-$ это ребро, которое соединяет вершину саму с собой.

> **определение** *простой граф* $-$ это граф, который не содержит петель и кратных ребер.

Чаще всего мы будем работать с простыми графами. В этой статье, если не сказано иного, речь идёт о простом графе.

> **определение** *ориентированный граф* $-$ это граф, в котором каждое ребро имеет направление, то есть ребро уже не просто соединяет две вершины, а в этой паре выбрано начало и конец ребра.

<img src="img\орграф.jpg" style="display: block; margin: auto; width: 50%; margin-bottom: 18px;" />

> **определение** *взвешенный граф* $-$ это граф, каждому ребру которого присвоено некоторое вещественное число, называемое весом ребра.

<img src="img\взвешенный.png" style="display: block; margin: auto; width: 50%; margin-bottom: 18px;" />

> **определение** *связный граф* $-$ это граф, в котором из любой вершины можно по ребрам дойти до любой другой. Относится только к неориентированным графам.

> **определение** *дерево* $-$ связный граф без циклов.

<img src="img\связности_и_циклы.png" style="display: block; margin: auto; width: 100%; margin-bottom: 18px;" />

> **определение** *путь* $-$ последовательность вершин $v_1, v_2, \ldots, v_k$ в графе, таких, что существует ребро из $v_i$ в $v_{i+1}$ для всех $1 \le i < k$.

> **определение** *компонента связности* $-$ максимальное по размеру множество вершин, между любой парой которых существует путь. 

Максимальное, означает невозможность добавить ещё одну вершину в компоненту, так чтобы она оставалось связной. Не путать с наибольшим.

На изображении выше, левый граф имеет 3 компоненты связности. Связный граф всегда имеет одну компоненту связности. 

> **определение** *цикл* $-$ путь, у которого начальная вершина ($v_1$) равна конечной вершине ($v_k$).

> **определение** *простой путь* $-$ путь, все вершины которого различны ($v_i \neq v_j$, для любых $1 \le i < j \le k$).

> **определение** *полный граф* $-$ граф, в котором каждая вершина соединена с каждой.

> **определение** *двудольный граф* $-$ граф, вершины которого можно разделить на два множества таких, что ребра соединяют только вершины из разных множеств.

В задачах на графы, чаще всего число вершин обозначают за $n$, а число рёбер — $m$.

## Способы хранения графов

https://ru.algorithmica.org/cs/graph-traversals/storing-graphs/

## Поиск в глубину

Обход в глубину (англ. Depth-First Search или DFS) $-$ простой, но многофункциональный алгоритм обхода графа по ребрам. Самое главное, что он может — это проверить, какие вершины достижимы из данной.

При обходе графа мы используем вспомогательный массив `used`, в котором храним $1$, если вершина была посещена или $0$ иначе. В начале мы считаем, что все вершины не использовались, затем мы выбираем одну вершину, помечаем ее посещенной и запускаемся рекурсивно из всех ее соседей, тогда мы посетим все вершины, которые достижимы из данной, если же остались вершины с `used` $= 0$ значит они недостижимы.

Красивая визуализация: https://visualgo.net/en/dfsbfs

```cpp
void dfs (int cur) {
    used[cur] = 1;
    for (auto next : g[cur]) {
        if (!used[next]) {
            dfs(next);
        }
    }
}
```

Давайте оценим сложность алгоритма. Так как мы проверяем, что вершина еще не использовалась, то всего мы пройдет каждую вершину $1$ раз, но при этом и ребро между двумя вершинами, мы рассматриваем только когда рассматривается один из его концов, то есть мы просмотрим каждое ребро не более двух раз, суммарно получаем оценку $\mathcal{O} (n + m)$.

### Поиск компонент связности графа

Требуется найти в неориентированном графе все компоненты связности, то есть разбить вершины графа на несколько групп так, что внутри одной группы можно дойти от одной вершины до любой другой, а между разными группами путей не существует.

Для решения задачи модифицируем обход в глубину так, чтобы запустившись от вершины какой-то компоненты, от пометил все вершины этой компоненты — то есть все достижимые вершины — заданным номером этой компоненты. Для этого можно массив used заменить массивом номеров компонент для каждой вершины, изначально заполненный нулями.

```cpp
const int maxn = 1e5;
int component[maxn]; // тут будут номера компонент

void dfs(int cur, int num) {
    component[cur] = num;
    for (int next : g[cur]) {
        // если номер не присвоен, то мы там ещё не были
        if (!component[next]) {
            dfs(next, num);
        }
    }
}
```

Теперь проведем серию обходов: сначала запустим обход из первой вершины, и все вершины, которые он при этом обошёл, образуют первую компоненту связности. Затем найдём первую из оставшихся вершин, которые ещё не были посещены, и запустим обход из неё, найдя тем самым вторую компоненту связности. И так далее, пока все вершины не станут помеченными.

Записывается это очень компактно:

```cpp
    int num = 0;
    for (int v = 0; v < n; v++) {
        if (!component[v]) dfs(v, ++num);
    }
```

После этого переменная num будет хранить число компонент связности, а массив component — номер компоненты для каждой вершины, который, например, можно использовать, чтобы быстро проверять, существует ли путь между заданной парой вершин.

Итоговая асимптотика будет как и у обычного обхода в глубину ($\mathcal{O} (n + m)$), потому что такой алгоритм не будет запускаться от одной и той же вершины дважды, и каждое ребро будет просмотрено ровно два раза (с одного конца и с другого).

## Поиск в ширину

Поиск в ширину (англ. breadth-first search или BFS) $-$ один из основных алгоритмов на графах, позволяющий находить все кратчайшие пути от заданной вершины и решать многие другие задачи.

Поиск в ширину также называют обходом $-$ так же, как поиск в глубину и все другие обходы, он посещает все вершины графа по одному разу, только в другом порядке: по увеличению расстояния до начальной вершины.

На вход алгоритма подаётся невзвешенный граф и номер стартовой вершины $s$. Граф может быть как ориентированным, так и неориентированным — для алгоритма это не важно.

Основную идею алгоритма можно понимать как процесс «поджигания» графа: на нулевом шаге мы поджигаем вершину 
$s$, а на каждом следующем шаге огонь с каждой уже горящей вершины перекидывается на всех её соседей, в конечном счете поджигая весь граф.

Если моделировать этот процесс, то за каждую итерацию алгоритма будет происходить расширение «кольца огня» в ширину на единицу. Номер шага, на котором вершина $v$ начинает гореть, в точности равен длине её минимального пути из вершины $s$.

<img src="img\bfs.png" style="display: block; margin: auto; width: 90%; margin-bottom: 18px;" />

Моделировать это можно следующим образом. Создадим очередь, в которую будут помещаться горящие вершины, а также заведём булевый массив, в котором для каждой вершины будем отмечать, горит она или нет — или иными словами, была ли она уже посещена. Изначально в очередь помещается только вершина 
$s$, которая сразу помечается горящей.

Затем алгоритм представляет собой такой цикл: пока очередь не пуста, достать из её головы одну вершину $v$, просмотреть все рёбра, исходящие из этой вершины, и если какие-то из смежных вершин $u$ ещё не горят, поджечь их и поместить в конец очереди.

В итоге, когда очередь опустеет, мы по одному разу обойдём все достижимые из $s$ вершины, причём до каждой дойдём кратчайшим путём. Длины кратчайших путей можно посчитать, если завести для них отдельный массив $d$ и при добавлении в очередь пересчитывать по правилу $d_u = d_v + 1$. Также можно компактно сохранить дополнительную информацию для восстановления самих путей, заведя массив «предков», в котором для каждой вершины хранится номер вершины из которой мы в неё попали.

Если мы всё равно поддерживаем массив расстояний, то отдельный булевый массив с метками горящих вершин можно не создавать, а вместо этого просто присвоить изначальное расстояние всех вершин некоторым некоторым специальным значением (например, $-1$), которое будет сигнализировать а том, что эту вершину мы ещё не просмотрели.

```cpp
    vector<int> g[maxn];

    void bfs(int s) {
        queue<int> q;
        q.push(s);
        
        vector<int> d(n, -1), p(n);
        d[s] = 0;
        
        while (q.size()) {
            int cur = q.front();
            q.pop();
            for (int next : g[cur]) {
                if (d[next] == -1) {
                    q.push(next);
                    d[next] = d[cur] + 1;
                    p[next] = cur;
                }
            }
        }
    } 
```

Теперь, чтобы восстановить кратчайший путь до какой-то вершины $v$, это можно сделать через массив $p$:

```cpp
    while (v != s) {
        cout << v << endl;
        v = p[v];
    }
```

Обратим внимание, что путь выведется в обратном порядке.

Алгоритм внутри очереди рассмотрит каждую вершину не более $1$ раза, и все рёбра инцедентные ей тоже, а значит итоговое время работы алгоритма составит $\mathcal{O} (n + m)$.