# Строки. Начало

## 1. Префикс-функция 

### Определение
Для строки $S$ префикс-функция — это массив $\pi$ длины $N$, где $\pi[i]$ — длина **наибольшего собственного префикса** подстроки $S[0 \dots i]$, который совпадает с её **суффиксом**.
*   **Собственный префикс:** префикс, не совпадающий со всей строкой.
*   $\pi[0] = 0$ всегда.

**Пример:** $S = \text{abacaba}$
*   $i=0$ (`a`): $\pi[0] = 0$
*   $i=1$ (`ab`): нет совпадений $\rightarrow 0$
*   $i=2$ (`aba`): префикс `a` == суффикс `a` $\rightarrow 1$
*   $i=3$ (`abac`): нет совпадений $\rightarrow 0$
*   ...
*   Результат: $[0, 0, 1, 0, 1, 2, 3]$

### Алгоритм (КМП — Кнута-Морриса-Пратта)
Наивный подсчет работает за $O(N^2)$ или $O(N^3)$. Эффективный алгоритм использует значения, вычисленные на предыдущих шагах.

**Идея:**
Чтобы найти $\pi[i]$, мы пытаемся расширить суффикс длины $\pi[i-1]$.
Пусть $j = \pi[i-1]$. Мы сравниваем символ $S[i]$ и $S[j]$.
1.  Если $S[i] == S[j]$, то $\pi[i] = j + 1$.
2.  Если не равны, мы пытаемся взять меньший суффикс, который уже был найден внутри $j$. Новая длина кандидата $j = \pi[j-1]$. Повторяем, пока не совпадет или $j$ не станет 0.

**Сложность:** $O(N)$ (амортизированная, переменная $j$ в сумме увеличивается $N$ раз и уменьшается не более $N$ раз).

### Реализация (C++)
```cpp
vector<int> prefix_function(const string& s) {
    int n = s.length();
    vector<int> pi(n);
    for (int i = 1; i < n; i++) {
        int j = pi[i-1]; // Длина предыдущего лучшего префикса
        while (j > 0 && s[i] != s[j]) {
            j = pi[j-1]; // Прыгаем к меньшему кандидату
        }
        if (s[i] == s[j]) {
            j++;
        }
        pi[i] = j;
    }
    return pi;
}
```

### Применение
1.  **Поиск подстроки в строке (КМП):** Ищем $P$ в $T$. Строим префикс-функцию для строки $P + \# + T$. Где значение равно длине $P$, там вхождение.
2.  **Поиск периода строки:** Длина минимального периода строки длины $N$ равна $N - \pi[N-1]$ (если $N$ делится на эту разность).

---

## 2. Z-функция (Z-Function)

### Определение
Для строки $S$ Z-функция — это массив $z$ длины $N$, где $z[i]$ — длина **наибольшего общего префикса** (LCP) строки $S$ и её суффикса, начинающегося с позиции $i$ ($S[i \dots N-1]$).
*   $z[0] = 0$ (обычно не вычисляется, считается равным 0 или длине строки, в олимпиадах чаще 0).

**Пример:** $S = \text{abacaba}$
*   $i=1$ (`bac...` vs `abac...`): 0
*   $i=2$ (`ac...` vs `abac...`): совпадает `a` $\rightarrow 1$
*   $i=3$ (`c...`): 0
*   $i=4$ (`aba` vs `abacaba`): совпадают `aba` $\rightarrow 3$
*   Результат: $[0, 0, 1, 0, 3, 0, 1]$

### Алгоритм
Поддерживаем отрезок $[L, R]$, который является самым правым обнаруженным совпадением префикса строки (так называемый Z-блок).
Для текущего $i$:
1.  Если $i > R$: Считаем $z[i]$ "в лоб" и обновляем $L, R$.
2.  Если $i \le R$: Мы уже знаем информацию. $z[i]$ инициализируется как $\min(R - i + 1, z[i - L])$.
    *   $z[i - L]$ — это уже посчитанное значение для соответствующей точки в начале строки.
    *   После инициализации пытаемся "досчитать" $z[i]$ вправо, если вышли за границы $R$.

**Сложность:** $O(N)$.

### Реализация (C++)
```cpp
vector<int> z_function(const string& s) {
    int n = s.length();
    vector<int> z(n);
    int l = 0, r = 0;
    for (int i = 1; i < n; i++) {
        // Инициализация по ранее найденному отрезку
        if (i <= r)
            z[i] = min(r - i + 1, z[i - l]);
        
        // Наивное расширение
        while (i + z[i] < n && s[z[i]] == s[i + z[i]])
            z[i]++;
            
        // Обновление правого Z-блока
        if (i + z[i] - 1 > r) {
            l = i;
            r = i + z[i] - 1;
        }
    }
    return z;
}
```

### Применение
1.  **Поиск подстроки:** Аналогично КМП, строим $z$ для $P + \# + T$.
2.  **Поиск палиндромов:** Применяется к строке $S + \# + reverse(S)$.

---

## 3. Полиномиальное хеширование (Hashing)

### Идея
Сопоставить каждой строке (или подстроке) число (хеш). Сравнение чисел выполняется за $O(1)$. Если хеши равны, строки скорее всего равны.

### Формула (Rolling Hash)
Строка рассматривается как число в системе счисления с основанием $P$ по модулю $M$.
$$H(S) = (S[0] \cdot P^0 + S[1] \cdot P^1 + \dots + S[N-1] \cdot P^{N-1}) \pmod M$$

*   **P (основание):** простое число, чуть больше размера алфавита (31, 53).
*   **M (модуль):** большое простое число ($10^9 + 7$, $10^9 + 9$).

### Хеш произвольной подстроки $S[L \dots R]$
Чтобы не пересчитывать хеш заново, используют массив префиксных хешей `h` и степеней `pow`.
$$Hash(S[0 \dots i]) = h[i]$$
Тогда хеш подстроки:
$$Hash(L, R) \cdot P^L = (h[R] - h[L-1]) \pmod M$$
При сравнении двух подстрок мы приводим их к одной степени, чтобы избежать деления (взятия обратного элемента по модулю).
**Условие равенства подстрок:**
$$(h[R_1] - h[L_1-1]) \cdot P^{L_2} \equiv (h[R_2] - h[L_2-1]) \cdot P^{L_1} \pmod M$$

### Коллизии
Ситуация, когда разные строки имеют одинаковый хеш.
*   **Решение:** Двойное хеширование. Считать два хеша с разными парами $(P_1, M_1)$ и $(P_2, M_2)$. Вероятность коллизии стремится к нулю.

### Реализация (C++)
```cpp
typedef long long ll;
const int MAXN = 100005;
const ll P = 31;
const ll M = 1e9 + 9;

ll pows[MAXN]; // Степени P
ll h[MAXN];    // Префиксные хеши

void build_hash(const string& s) {
    int n = s.length();
    pows[0] = 1;
    h[0] = 0; // Для удобства индексация с 1 в массиве h
    
    for (int i = 0; i < n; i++) {
        pows[i+1] = (pows[i] * P) % M;
        h[i+1] = (h[i] + (s[i] - 'a' + 1) * pows[i]) % M;
    }
}

// Получение хеша подстроки s[L..R] (0-индексация) без сдвига степени
ll get_hash(int L, int R) {
    ll res = (h[R+1] - h[L] + M) % M;
    // res сейчас равен Hash * P^L. 
    // Обычно возвращают именно это значение для сравнения.
    return res;
}

// Сравнение подстрок s[i..i+len-1] и s[j..j+len-1]
bool are_equal(int i, int j, int len) {
    ll h1 = get_hash(i, i + len - 1);
    ll h2 = get_hash(j, j + len - 1);
    
    // Приводим к общей степени P^(max(i, j))
    if (i < j) h1 = (h1 * pows[j - i]) % M;
    else       h2 = (h2 * pows[i - j]) % M;
    
    return h1 == h2;
}
```

### Применение
1.  **Сравнение подстрок за O(1).**
2.  **Алгоритм Рабина-Карпа:** поиск подстроки в тексте.
3.  **Количество различных подстрок:** хешируем все подстроки и кладем в `std::set` (или сортируем).
4.  **Поиск палиндрома максимальной длины:** хеши (прямой + перевернутый) + бинпоиск по длине.

---

### Сравнение подходов

| Метод | Сложность построения | Сложность запроса | Преимущества |
| :--- | :--- | :--- | :--- |
| **Префикс-функция** | $O(N)$ | $O(1)$ (значение) | Лучший для поиска периода и КМП. |
| **Z-функция** | $O(N)$ | $O(1)$ (значение) | Интуитивнее для совпадений префиксов, часто проще в задачах. |
| **Хеши** | $O(N)$ | $O(1)$ (сравнение) | Универсальный "молоток". Решает задачи, где структура строк сложна (палиндромы, сравнение произвольных кусков). Вероятностный метод. |