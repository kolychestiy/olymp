# Базовые структуры данных. Контейнеры STL

## 1. Стек (Stack)

### 1.1. Что такое стек?

**Стек** — это линейная структура данных, работающая по принципу **LIFO (Last-In, First-Out)**, что переводится как «последним пришёл — первым вышел». Представить стек можно как стопку тарелок: вы можете добавить новую тарелку только сверху и взять можете тоже только верхнюю.

**Основные операции со стеком:**
*   `push(element)`: Добавить элемент на вершину стека.
*   `pop()`: Удалить и вернуть элемент с вершины стека.
*   `top()` (или `peek()`): Посмотреть значение верхнего элемента, не удаляя его.
*   `is_empty()`: Проверить, пуст ли стек.
*   `size()`: Узнать количество элементов в стеке.

Все основные операции со стеком (`push`, `pop`, `top`) в стандартных реализациях выполняются за константное время — **O(1)**.

### 1.2. Самописный стек с помощью массива

В олимпиадном программировании иногда полезно уметь быстро написать свою реализацию стека, например, на статическом массиве, чтобы оптимизировать затрачиваемые время и память.

**Принцип:**
1.  Заводим массив большого размера (с запасом под максимальное количество элементов).
2.  Храним целочисленный указатель (индекс) `top_ptr` на вершину стека. Изначально он равен -1 или 0, в зависимости от реализации.
3.  `push`: увеличиваем `top_ptr` и записываем элемент в массив по этому индексу.
4.  `pop`: уменьшаем `top_ptr`.
5.  `top`: возвращаем элемент по индексу `top_ptr`.

**Пример реализации на C++:**

```cpp
#include <iostream>
#include <stdexcept>

const int MAX_SIZE = 1000; // Максимальный размер стека

template <typename T>
class MyStack {
private:
    T arr[MAX_SIZE];
    int top_ptr;

public:
    MyStack() : top_ptr(-1) {}

    bool isEmpty() const {
        return top_ptr == -1;
    }

    bool isFull() const {
        return top_ptr == MAX_SIZE - 1;
    }

    void push(T value) {
        if (isFull()) {
            throw std::overflow_error("Stack is full");
        }
        arr[++top_ptr] = value;
    }

    T pop() {
        if (isEmpty()) {
            throw std::underflow_error("Stack is empty");
        }
        return arr[top_ptr--];
    }

    T top() const {
        if (isEmpty()) {
            throw std::underflow_error("Stack is empty");
        }
        return arr[top_ptr];
    }

    int size() const {
        return top_ptr + 1;
    }
};
```

### 1.3. Применение стека: "Ближайший меньший сосед"

Это классическая задача, которая эффективно решается с помощью стека за линейное время **O(N)**.

**Постановка задачи:**
Дан массив чисел `a`. Для каждого элемента `a[i]` нужно найти индекс `j` такого элемента `a[j]`, что `j < i`, `a[j] < a[i]` и при этом `j` — максимально возможный (т.е. ближайший слева). Если такого элемента нет, ответ -1.

**Алгоритм:**
1.  Создаем пустой стек, в котором будем хранить *индексы* элементов.
2.  Идем по массиву `a` слева направо (от `i = 0` до `n-1`).
3.  Для каждого элемента `a[i]`:
    *   Пока стек не пуст и элемент на вершине стека `a[st.top()]` больше или равен `a[i]`, удаляем элементы из стека (`st.pop()`).
    *   После цикла `while` на вершине стека окажется индекс ближайшего элемента слева, который меньше текущего. Если стек пуст, такого элемента нет.
    *   Записываем ответ для `i`: если стек не пуст, то это `st.top()`, иначе -1.
    *   Добавляем текущий индекс `i` в стек (`st.push(i)`).

**Почему это работает?** Стек поддерживает последовательность индексов, элементы которых образуют возрастающую последовательность. Когда мы встречаем новый элемент `a[i]`, мы удаляем из стека все элементы, которые "хуже" (больше или равны), так как для всех последующих элементов они уже не смогут быть ближайшим меньшим соседом — `a[i]` будет ближе и меньше.

**Пример реализации на C++:**

```cpp
#include <iostream>
#include <vector>
#include <stack>

std::vector<int> nearestSmallerToLeft(const std::vector<int>& arr) {
    int n = arr.size();
    std::vector<int> result(n);
    std::stack<int> s; // Храним индексы

    for (int i = 0; i < n; ++i) {
        while (!s.empty() && arr[s.top()] >= arr[i]) {
            s.pop();
        }
        if (s.empty()) {
            result[i] = -1;
        } else {
            result[i] = s.top();
        }
        s.push(i);
    }
    return result;
}
```

---

## 2. Очередь (Queue)

### 2.1. Что такое очередь?

**Очередь** — это структура данных, которая работает по принципу **FIFO (First-In, First-Out)**, что означает «первым пришёл — первым вышел». Это похоже на обычную очередь в магазине: кто первый пришел, того первого и обслужат. У очереди есть "голова" (начало) и "хвост" (конец).

**Основные операции с очередью:**
*   `enqueue(element)` (или `push`): Добавить элемент в хвост очереди.
*   `dequeue()` (или `pop`): Удалить и вернуть элемент из головы очереди.
*   `front()` (или `peek`): Посмотреть значение элемента в голове, не удаляя его.
*   `isEmpty()`: Проверить, пуста ли очередь.
*   `size()`: Узнать количество элементов.

Как и у стека, основные операции выполняются за **O(1)**.

### 2.2. Очередь с помощью двух стеков

Это популярная задача на собеседованиях и олимпиадах, демонстрирующая гибкость структур данных.

**Идея:**
*   Используем два стека: `s1` (для добавления) и `s2` (для извлечения).
*   **`enqueue(value)`:** Всегда добавляем элемент в `s1`.
*   **`dequeue()`:**
    *   Если `s2` пуст, перекладываем все элементы из `s1` в `s2`. При этом порядок элементов инвертируется, и тот, что был на дне `s1` (добавлен самым первым), окажется на вершине `s2`.
    *   Теперь извлекаем элемент из вершины `s2`.
    *   Если `s2` не пуст, просто извлекаем элемент из его вершины.

**Амортизированная сложность:**
Хотя одна операция `dequeue` может занять O(N) времени (когда происходит перекладывание), каждый элемент перекладывается из `s1` в `s2` только один раз. Поэтому в среднем (амортизированно) сложность каждой операции остается **O(1)**.

**Пример реализации на C++:**
```cpp
#include <stack>
#include <stdexcept>

template <typename T>
class QueueWithStacks {
private:
    std::stack<T> s1, s2;

    void move_s1_to_s2() {
        if (s2.empty()) {
            while (!s1.empty()) {
                s2.push(s1.top());
                s1.pop();
            }
        }
    }

public:
    void enqueue(T value) {
        s1.push(value);
    }

    T dequeue() {
        move_s1_to_s2();
        if (s2.empty()) {
            throw std::underflow_error("Queue is empty");
        }
        T value = s2.top();
        s2.pop();
        return value;
    }

    T front() {
        move_s1_to_s2();
        if (s2.empty()) {
            throw std::underflow_error("Queue is empty");
        }
        return s2.top();
    }
};
```

### 2.3. Очередь на одном циклическом массиве

Это самый эффективный способ реализации очереди на массиве, также известный как **кольцевой буфер**.

**Принцип:**
1.  Выделяем массив `arr` фиксированного размера `capacity`.
2.  Используем два указателя (индекса): `head` (указывает на первый элемент) и `tail` (указывает на *следующую* свободную ячейку после последнего элемента).
3.  **`enqueue(value)`:** `arr[tail] = value`, затем сдвигаем `tail`: `tail = (tail + 1) % capacity`.
4.  **`dequeue()`:** Забираем `arr[head]`, затем сдвигаем `head`: `head = (head + 1) % capacity`.
5.  **Проверка на пустоту:** `head == tail`.
6.  **Проверка на переполнение:** `(tail + 1) % capacity == head`.

**Пример реализации на C++:**
```cpp
#include <stdexcept>
#include <vector>

template <typename T>
class CircularQueue {
private:
    std::vector<T> arr;
    int head, tail, count, capacity;

public:
    CircularQueue(int size) : capacity(size + 1), head(0), tail(0), count(0) {
        arr.resize(capacity);
    }

    bool isEmpty() const {
        return count == 0;
    }

    bool isFull() const {
        return count == capacity - 1;
    }

    void enqueue(T value) {
        if (isFull()) {
            throw std::overflow_error("Queue is full");
        }
        arr[tail] = value;
        tail = (tail + 1) % capacity;
        count++;
    }

    T dequeue() {
        if (isEmpty()) {
            throw std::underflow_error("Queue is empty");
        }
        T value = arr[head];
        head = (head + 1) % capacity;
        count--;
        return value;
    }
};
```
### 2.4. Очередь с поддержкой минимума за O(1)

**Задача:** реализовать очередь, которая поддерживает стандартные операции `enqueue`, `dequeue` и дополнительную операцию `getMin()`, возвращающую минимальный элемент в текущей очереди. Все операции должны выполняться за амортизированное время **O(1)**.

**Решение 1: Два стека с поддержкой минимума**
1.  Сначала реализуем стек, который поддерживает `getMin()` за O(1). Это делается хранением в стеке пар `{элемент, текущий_минимум}`. При добавлении нового элемента, новый минимум — это `min(новый_элемент, старый_минимум)`.
2.  Затем строим очередь на двух таких "минимальных" стеках.
3.  Операция `getMin()` для очереди будет `min(s1.getMin(), s2.getMin())`.

**Решение 2 (более оптимальное): Использование двусторонней очереди (дека)**
Этот метод используется для решения задачи "минимум в скользящем окне" и идеально подходит сюда.
1.  Заводим дек (deque), в котором будем хранить элементы из нашей очереди.
2.  **Важное свойство:** Дек будет хранить элементы в порядке возрастания их значений. Таким образом, минимум всегда будет в `deque.front()`.
3.  **`enqueue(value)`:**
    *   Пока дек не пуст и `deque.back() > value`, удаляем элементы из конца дека.
    *   Добавляем `value` в конец дека.
4.  **`dequeue()`:**
    *   Если элемент, который мы удаляем из основной очереди, равен `deque.front()`, то удаляем его и из дека.
5.  **`getMin()`:**
    *   Всегда возвращает `deque.front()`.

Этот подход гарантирует, что в голове дека всегда находится актуальный минимум для текущих элементов в очереди. Все операции имеют амортизированную сложность O(1), так как каждый элемент добавляется и удаляется из дека не более одного раза.


## Контейнеры STL C++

Рекомендуется использовать заголовочный файл `<bits/stdc++.h>`, который содержит в себе почти всё, что может пригодится на олимпиаде. Если же вы используете компилятор, не поддерживающий такой заголовочный файл, или возникает необходимость ускорить компиляцию исходного кода (обычно на старом железе), можете подключать каждый контейнер отдельно.

### 1. Вектор (`vector`)

**Заголовочный файл:** `<vector>`

**Краткое описание:** `vector` представляет собой динамический массив, который хранит элементы в непрерывном блоке памяти. Это один из наиболее часто используемых контейнеров благодаря своей простоте и эффективности.

**Внутреннее устройство:** Основан на обычном массиве. Когда количество элементов превышает текущую емкость, вектор выделяет новый, больший массив (обычно в 1.5-2 раза больше), копирует туда все старые элементы и удаляет старый массив. Этот процесс называется реалокацией.

**Ключевые операции и их сложность:**

| Операция | Метод | Амортизированная сложность | Худший случай |
| :--- | :--- | :--- | :--- |
| Доступ к элементу по индексу | `[]`, `at()` | O(1) | O(1) |
| Добавление элемента в конец | `push_back()` | O(1) | O(N) |
| Удаление элемента с конца | `pop_back()` | O(1) | O(1) |
| Вставка/удаление в произвольное место | `insert()`, `erase()`| O(N) | O(N) |
| Получение размера | `size()` | O(1) | O(1) |
| Очистка вектора | `clear()` | O(N) (вызов деструкторов) | O(N) |

**Преимущества:**
*   **Быстрый доступ по индексу (O(1))**: Благодаря тому, что элементы хранятся последовательно друг за другом в памяти.
*   **Эффективное добавление/удаление в конце (амортизированное O(1))**: Идеально подходит для сценариев, где основная работа происходит с концом массива.
*   **Хорошая локальность кэша**: Элементы расположены рядом в памяти, что ускоряет итерирование.

**Недостатки:**
*   **Медленная вставка и удаление в начале или середине (O(N))**: Требуется сдвиг всех последующих элементов.
*   **Возможные реалокации**: При добавлении элементов может происходить дорогостоящая операция выделения новой памяти и копирования.



---

### 2. Стек (`stack`)

**Заголовочный файл:** `<stack>`

**Краткое описание:** `stack` — это контейнер-адаптер, реализующий структуру данных "стек" по принципу LIFO ("Last-In, First-Out" — "последним пришел, первым ушел").

**Внутреннее устройство:** `stack` не является самостоятельным контейнером. Это оболочка над другим контейнером, по умолчанию `deque`. Также может использовать `vector` или `list`.

**Ключевые операции и их сложность:**

| Операция | Метод | Сложность |
| :--- | :--- | :--- |
| Добавление элемента на вершину стека | `push()` | O(1) (аморт. для vector) |
| Удаление элемента с вершины | `pop()` | O(1) |
| Доступ к верхнему элементу | `top()` | O(1) |
| Проверка на пустоту | `empty()` | O(1) |
| Получение размера | `size()` | O(1) |



**Примеры применения в олимпиадах:**
*   **Проверка правильности скобочных последовательностей:** Один из классических примеров использования стека.
*   **Вычисление выражений в обратной польской нотации.**
*   **Поиск ближайшего меньшего/большего элемента:** Для каждого элемента массива найти ближайший элемент слева/справа, который меньше/больше него.

---

### 3. Очередь (`queue`)

**Заголовочный файл:** `<queue>`

**Краткое описание:** `queue` — это контейнер-адаптер, реализующий структуру данных "очередь" по принципу FIFO ("First-In, First-Out" — "первым пришел, первым ушел").

**Внутреннее устройство:** Как и `stack`, `queue` является адаптером. По умолчанию он использует `deque`, но также может быть построен на основе `list`.

**Ключевые операции и их сложность:**

| Операция | Метод | Сложность |
| :--- | :--- | :--- |
| Добавление элемента в конец | `push()` | O(1) |
| Удаление элемента из начала | `pop()` | O(1) |
| Доступ к первому элементу | `front()` | O(1) |
| Доступ к последнему элементу | `back()` | O(1) |
| Проверка на пустоту | `empty()` | O(1) |
| Получение размера | `size()` | O(1) |



---

### 4. Дек (`deque`)

**Заголовочный файл:** `<deque>`

**Краткое описание:** `deque` (double-ended queue) — это двухсторонняя очередь. Она похожа на `vector`, но позволяет эффективно добавлять и удалять элементы как в начало, так и в конец.

**Внутреннее устройство:** В отличие от вектора, `deque` не хранит элементы в одном непрерывном блоке памяти. Обычно он реализован как массив указателей на фиксированные блоки (чанки) памяти, где и хранятся элементы.

**Ключевые операции и их сложность:**

| Операция | Метод | Сложность |
| :--- | :--- | :--- |
| Доступ к элементу по индексу | `[]`, `at()` | O(1) (но с большей константой, чем у vector) |
| Добавление/удаление в конец | `push_back()`, `pop_back()` | O(1) |
| Добавление/удаление в начало | `push_front()`, `pop_front()` | O(1) |
| Вставка/удаление в середине | `insert()`, `erase()`| O(N) |
| Получение размера | `size()` | O(1) |

**Преимущества:**
*   **Быстрые вставки/удаления с обоих концов (O(1)).**
*   Не требует перемещения всех элементов при росте, в отличие от `vector`.

**Недостатки:**
*   Доступ по индексу медленнее, чем у `vector` из-за дополнительного уровня косвенности.
*   Худшая локальность кэша по сравнению с вектором.
*   Более сложная внутренняя структура и больший расход памяти на служебные данные.

<!-- **Применение в олимпиадах:**
*   Когда нужен быстрый доступ к элементам по индексу и одновременно эффективные операции в начале и в конце.
*   **Алгоритм поиска кратчайшего пути 0-1 BFS:** Где веса ребер могут быть только 0 или 1.
*   **Задача о скользящем минимуме/максимуме:** Эффективно решается с помощью дека. -->



---

### 5. Связный список (`list`, `forward_list`)

**Заголовочный файл:** `<list>`, `<forward_list>`

**Краткое описание:**
*   `list`: двусвязный список. Каждый элемент хранит указатели на следующий и предыдущий элементы.
*   `forward_list`: односвязный список. Каждый элемент хранит указатель только на следующий элемент.

**Внутреннее устройство:** Набор узлов, разбросанных по памяти. Каждый узел содержит само значение и один или два указателя на соседей.

**Ключевые операции и их сложность (для `list`):**

| Операция | Метод | Сложность |
| :--- | :--- | :--- |
| Доступ к элементу по индексу | - (нет `[]` или `at()`) | O(N) |
| Вставка/удаление элемента | `insert()`, `erase()` | O(1) (при наличии итератора) |
| Добавление/удаление в конец | `push_back()`, `pop_back()` | O(1) |
| Добавление/удаление в начало | `push_front()`, `pop_front()` | O(1) |
| Слияние списков | `splice()` | O(1) или O(N) в зависимости от версии |
| Получение размера | `size()` | O(1) (начиная с C++11) |

**Преимущества:**
*   **Быстрая вставка и удаление в любом месте (O(1))**, если у вас есть итератор на позицию.
*   Итераторы не инвалидируются при вставке или удалении элементов (кроме итераторов на удаляемые элементы).

**Недостатки:**
*   **Медленный доступ к элементу по индексу (O(N))**: Необходимо последовательно проходить по списку от начала или конца.
*   **Плохая локальность кэша**: Элементы разбросаны по памяти, что замедляет итерирование.
*   Дополнительные расходы памяти на хранение указателей.



<!-- **Применение в олимпиадах:**
*   В задачах, где постоянно происходят вставки/удаления элементов в середину структуры данных и не требуется быстрый доступ по индексу.
*   Реализация некоторых алгоритмов, где важна операция `splice` (быстрое перемещение частей одного списка в другой).
*   В целом, в олимпиадном программировании `list` используется редко из-за медленного доступа и плохой производительности кэша. `vector` или `deque` часто оказываются быстрее даже при вставках в середину на небольших и средних данных. -->

---

### 6. Упорядоченное множество (`set`, `multiset`)

**Заголовочный файл:** `<set>`

**Краткое описание:**
*   `set`: ассоциативный контейнер, который хранит **уникальные** элементы в отсортированном порядке.
*   `multiset`: то же, что и `set`, но позволяет хранить **дубликаты** элементов.

**Внутреннее устройство:** Обычно реализованы на основе сбалансированного двоичного дерева поиска, чаще всего красно-черного дерева.

**Ключевые операции и их сложность:**

| Операция | Метод | Сложность |
| :--- | :--- | :--- |
| Вставка элемента | `insert()` | O(log N) |
| Удаление элемента | `erase()` | O(log N) |
| Поиск элемента | `find()`, `count()` | O(log N) |
| Поиск первого элемента, не меньшего X | `lower_bound()` | O(log N) |
| Поиск первого элемента, большего X | `upper_bound()` | O(log N) |
| Получение размера | `size()` | O(1) |

**Преимущества:**
*   Автоматическая сортировка элементов.
*   Быстрый поиск, вставка и удаление (логарифмическое время).
*   Возможность быстро находить элементы в определенном диапазоне (`lower_bound`, `upper_bound`).

**Недостатки:**
*   Более медленные операции по сравнению с хэш-таблицами (O(log N) против амортизированного O(1)).
*   Элементы в `set` нельзя изменять напрямую, так как это может нарушить порядок сортировки. Нужно удалить старый элемент и вставить новый.

<!-- **Применение в олимпиадах:**
*   Подсчет количества уникальных элементов.
*   Поддержание набора элементов в отсортированном виде для быстрого доступа к минимальному/максимальному элементу или для поиска ближайших значений.
*   Задачи на "сканирующую прямую" (sweep-line), где требуется поддерживать активный отсортированный набор объектов.
*   Использование `lower_bound` и `upper_bound` для быстрого поиска элементов в диапазонах. -->



---

### 7. Неупорядоченное множество (`unordered_set`, `unordered_multiset`)

**Заголовочный файл:** `<unordered_set>`

**Краткое описание:**
*   `unordered_set`: ассоциативный контейнер, который хранит **уникальные** элементы без определенного порядка.
*   `unordered_multiset`: то же, что и `unordered_set`, но позволяет хранить **дубликаты**.

**Внутреннее устройство:** Реализованы на основе хэш-таблицы.

**Ключевые операции и их сложность:**

| Операция | Метод | Средняя сложность | Худший случай |
| :--- | :--- | :--- | :--- |
| Вставка элемента | `insert()` | O(1) | O(N) |
| Удаление элемента | `erase()` | O(1) | O(N) |
| Поиск элемента | `find()`, `count()` | O(1) | O(N) |
| Получение размера | `size()` | O(1) | O(1) |

**Преимущества:**
*   **Очень быстрая вставка, удаление и поиск (в среднем O(1))** — быстрее, чем у `set`.

**Недостатки:**
*   **Худший случай O(N)**: Возникает при коллизиях хэш-функции. В олимпиадном программировании иногда встречаются специальные тесты ("анти-хэш тесты"), которые могут вызвать такое поведение у стандартных хэш-функций.
*   **Нет порядка элементов**: Элементы хранятся в произвольном порядке. Невозможно использовать `lower_bound`/`upper_bound`.
*   Для пользовательских типов данных (структур, пар) необходимо определять свою хэш-функцию.



<!-- **Применение в олимпиадах:**
*   Максимально быстрый подсчет уникальных элементов или проверка на наличие элемента в наборе, когда порядок не важен.
*   Решение задач, где требуется O(1) проверка существования элемента, например, "найти два числа в массиве, дающие в сумме X".
*   При использовании с пользовательскими структурами или `pair` не забывайте писать собственную хэш-функцию. Для защиты от "анти-хэш тестов" можно использовать полиномиальное хэширование с хорошим случайным модулем и основанием. -->

### 8. Упорядоченное отображение (`map`)

**Заголовочный файл:** `<map>`

**Краткое описание:**
*   `map`: ассоциативный контейнер, который хранит пары "ключ-значение" (`key-value`), отсортированные по **уникальным** ключам.

**Внутреннее устройство:** Как и `set`, обычно реализованы на основе сбалансированного двоичного дерева поиска (например, красно-черного дерева).

**Ключевые операции и их сложность:**

| Операция | Метод | Сложность |
| :--- | :--- | :--- |
| Доступ/вставка элемента | `[]`, `at()` | O(log N) |
| Вставка пары "ключ-значение" | `insert()` | O(log N) |
| Удаление по ключу | `erase()` | O(log N) |
| Поиск по ключу | `find()`, `count()` | O(log N) |
| Поиск по ключу >= X | `lower_bound()` | O(log N) |
| Поиск по ключу > X | `upper_bound()` | O(log N) |

**Преимущества:**
*   Автоматическая сортировка по ключу.
*   Надежная логарифмическая сложность для всех основных операций.
*   Возможность итерирования по элементам в порядке возрастания ключей.

**Недостатки:**
*   Медленнее, чем `unordered_map`, для простых операций вставки/поиска/удаления.
*   Оператор `[]` создает элемент со значением по умолчанию, если ключ не найден. Это может быть нежелательным поведением.

---

### 9. Неупорядоченное отображение (`unordered_map`)

**Заголовочный файл:** `<unordered_map>`

**Краткое описание:**
*   `unordered_map`: хранит пары "ключ-значение" в виде хэш-таблицы. Ключи **уникальны**. Порядок элементов не гарантируется.

**Внутреннее устройство:** Реализованы на основе хэш-таблицы.

**Ключевые операции и их сложность:**

| Операция | Метод | Средняя сложность | Худший случай |
| :--- | :--- | :--- | :--- |
| Доступ/вставка элемента | `[]`, `at()` | O(1) | O(N) |
| Вставка пары "ключ-значение" | `insert()` | O(1) | O(N) |
| Удаление по ключу | `erase()` | O(1) | O(N) |
| Поиск по ключу | `find()`, `count()` | O(1) | O(N) |

**Преимущества:**
*   **Очень быстрые операции вставки, удаления и поиска (в среднем O(1))**. Это самый быстрый способ связать ключ со значением.

**Недостатки:**
*   **Худший случай O(N)** из-за коллизий (особенно уязвимо для "анти-хэш тестов").
*   **Нет порядка элементов.**
*   Большее потребление памяти по сравнению с `map`.
*   Требует написания хэш-функции для пользовательских типов данных в качестве ключей.
