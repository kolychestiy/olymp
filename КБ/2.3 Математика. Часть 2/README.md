# Математика. Часть 2

## 1. Комбинаторика: Основные понятия

### Основные правила
1.  **Правило произведения (AND):**
    Если действие $A$ можно выполнить $n$ способами, а действие $B$ — $m$ способами, то пару действий $(A, B)$ можно выполнить $n \times m$ способами.
    *Пример:* Выбрать футболку (3 вида) и шорты (4 вида) = $3 \times 4 = 12$ образов.

2.  **Правило суммы (OR):**
    Если действие $A$ можно выполнить $n$ способами, а действие $B$ — $m$ способами, причем способы не пересекаются, то выполнить действие $A$ **или** $B$ можно $n + m$ способами.

### Перестановки
Количество способов упорядочить $n$ различных элементов:
$$P_n = n! = 1 \cdot 2 \cdot 3 \cdot \dots \cdot n$$
*Примечание:* $0! = 1$.
*C++:* `next_permutation` (в `<algorithm>`) генерирует следующую лексикографическую перестановку.

---

## 2. Число сочетаний ($C_n^k$)

**Определение:** Количество способов выбрать $k$ элементов из $n$ различных элементов (порядок не важен).
Обозначается: $C_n^k$ или $\binom{n}{k}$.

### Формула
$$C_n^k = \frac{n!}{k!(n-k)!}$$

### Свойства
1.  **Симметрия:** $C_n^k = C_n^{n-k}$
2.  **Рекуррентная формула (Треугольник Паскаля):**
    $$C_n^k = C_{n-1}^{k-1} + C_{n-1}^k$$
    *(База: $C_n^0 = 1, C_n^n = 1$)*
3.  **Сумма биномиальных коэффициентов:** $\sum_{k=0}^n C_n^k = 2^n$

### Реализация
Прямой расчет через факториалы опасен переполнением. Используйте один из методов:

**А. Треугольник Паскаля (ДП) — для $N \le 2000$, работает с модулем**
```cpp
const int MAXN = 2000;
long long C[MAXN + 1][MAXN + 1];

void precomputeBinomial() {
    for (int n = 0; n <= MAXN; n++) {
        C[n][0] = 1;
        for (int k = 1; k <= n; k++) {
            C[n][k] = C[n-1][k-1] + C[n-1][k];
            // Если нужно по модулю: C[n][k] %= MOD;
        }
    }
}
```

**Б. Через факториалы и обратный элемент — для больших $N$ (по модулю простого числа)**
Требуется знание алгоритма быстрого возведения в степень (Modular Inverse).
$$C_n^k \equiv n! \cdot (k!)^{-1} \cdot ((n-k)! )^{-1} \pmod P$$

---

## 3. Типовые задачи на комбинаторику

1.  **Размещение шаров по ящикам (Stars and Bars):**
    Сколькими способами можно разложить $n$ одинаковых предметов по $k$ различным ящикам (ящики могут быть пустыми)?
    $$\text{Ответ: } C_{n+k-1}^{k-1}$$
    *Пример:* Найти количество решений $x_1 + x_2 + x_3 = 10$ в неотрицательных целых числах. Здесь $n=10, k=3$.

2.  **Правильная скобочная последовательность (ПСП):**
    Количество ПСП длины $2n$ равно **Числу Каталана**:
    $$Cat_n = \frac{1}{n+1} C_{2n}^n$$

3.  **Принцип включений-исключений:**
    Для подсчета количества элементов, обладающих хотя бы одним из свойств.
    $$|A \cup B| = |A| + |B| - |A \cap B|$$
    $$|A \cup B \cup C| = |A| + |B| + |C| - (|A \cap B| + |A \cap C| + |B \cap C|) + |A \cap B \cap C|$$

---

## 4. Делители числа

### Поиск всех делителей
Делители всегда идут парами: если $i$ делитель $N$, то $N/i$ тоже делитель. Достаточно перебирать до $\sqrt{N}$.

**Сложность:** $O(\sqrt{N})$
```cpp
vector<int> getDivisors(int n) {
    vector<int> divs;
    for (int i = 1; i * i <= n; i++) {
        if (n % i == 0) {
            divs.push_back(i);
            if (i * i != n) { // Избегаем дублирования для полного квадрата
                divs.push_back(n / i);
            }
        }
    }
    return divs;
}
```

### Количество делителей
Если каноническое разложение числа $n = p_1^{a_1} \cdot p_2^{a_2} \cdot \dots \cdot p_k^{a_k}$, то количество делителей $\tau(n)$:
$$\tau(n) = (a_1 + 1)(a_2 + 1)\dots(a_k + 1)$$

---

## 5. Факторизация числа

Представление числа в виде произведения простых множителей.

### Метод пробных делений
Перебираем делители $d$ от 2 до $\sqrt{N}$. Если $N$ делится на $d$, делим $N$ на $d$ пока делится, и записываем $d$.
Если после цикла $N > 1$, то оставшееся $N$ — простое число.

**Сложность:** $O(\sqrt{N})$ в худшем случае (для простого числа).

```cpp
vector<int> factorize(int n) {
    vector<int> factors;
    for (int i = 2; i * i <= n; i++) {
        while (n % i == 0) {
            factors.push_back(i);
            n /= i;
        }
    }
    if (n > 1) {
        factors.push_back(n);
    }
    return factors;
}
```
*Для множественных запросов факторизации лучше использовать Решето Эратосфена (предподсчет минимального простого делителя `lp[i]`).*

---

## 6. Решето Эратосфена

Алгоритм поиска всех простых чисел до $N$.

### Алгоритм
1.  Создать массив `isPrime` длины $N+1$, заполненный `true`.
2.  `isPrime[0] = isPrime[1] = false`.
3.  Идти циклом $i$ от 2 до $N$.
4.  Если `isPrime[i]` истинно, то $i$ — простое. Зачеркнуть (пометить `false`) все кратные $i$ числа, начиная с $i^2$ ($2i, 3i$ уже зачеркнуты меньшими простыми).

**Сложность:** $O(N \log \log N)$.
Для $N = 10^7$ работает меньше секунды.

```cpp
const int MAXN = 1000000;
vector<bool> isPrime(MAXN + 1, true);

void sieve() {
    isPrime[0] = isPrime[1] = false;
    for (int i = 2; i * i <= MAXN; i++) {
        if (isPrime[i]) {
            // Начинаем с i*i, так как меньшие кратные уже помечены
            // Осторожно с переполнением i*i для больших int!
            for (int j = i * i; j <= MAXN; j += i)
                isPrime[j] = false;
        }
    }
}
```

### Линейное решето (Linear Sieve)
Позволяет найти простые числа и `lp[i]` (минимальный простой делитель) за $O(N)$.
`lp[i]` крайне полезен для факторизации любого числа до $N$ за $O(\log N)$.

---

## 7. Сумма гармонического ряда

**Гармонический ряд:**
$$H_n = 1 + \frac{1}{2} + \frac{1}{3} + \dots + \frac{1}{n} = \sum_{k=1}^n \frac{1}{k}$$

### Асимптотика
$$H_n \approx \ln(n) + \gamma$$
где $\gamma \approx 0.577$ (постоянная Эйлера-Маскерони).
То есть $H_n$ растет как логарифм $O(\log n)$.

### Важное применение в олимпиадах
Часто встречается цикл вида «перебрать все числа $i$ и для каждого сделать прыжки с шагом $i$» (похоже на решето Эратосфена, но для всех чисел, а не только простых).

```cpp
// Задача: найти сумму делителей для всех чисел от 1 до N
for (int i = 1; i <= n; i++) {
    for (int j = i; j <= n; j += i) {
        // число i является делителем числа j
        divisorsSum[j] += i;
    }
}
```
**Сложность этого кода:**
$$ \frac{N}{1} + \frac{N}{2} + \frac{N}{3} + \dots + \frac{N}{N} = N \left( 1 + \frac{1}{2} + \dots + \frac{1}{N} \right) \approx N \ln N $$
**Вывод:** Перебор кратных для всех чисел до $N$ работает за $O(N \log N)$, а не $O(N^2)$. Это очень быстрый и мощный прием.