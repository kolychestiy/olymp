# Бинарный и тернарный поиск, 2 указателя

## Бинарный поиск

Рассмотрим следующую игру. Вася загадывает целое число от $1$ до $1000$. Петя в свою очередь может выбирать любое целое $x$ и спрашивать у Васи: «Загаданное тобой число меньше $x$?». Вася отвечает «Нет» или «Да». Петя хочет как можно быстрее выиграть в эту игру. Как ему это сделать?

Простым решением будет спрашивать например по очереди числа $1$, $2$, $3$, и т.д., пока Вася не ответит «Да». Тогда ответом будет последнее названное число $-1$. Однако игра будет длитя долго, и в худшем случае необходимо будет перебрать все $1000$ чисел. А если загаданное число было бы например в промежутке от $1$ до $10^9$, то ребятам возможно не хватило бы даже целой жизни, чтобы завершить игру. Время работы такого алгоритмы оценивается как $\mathcal{O}(len)$, где $len$ - длина промежутка, на котором было загадано число.

Поэтому сделаем важное наблюдение. Если мы спросили некоторый $x$ и получили ответ «Нет», то загаданное число $\ge x$. Иначе, загаданное число $< x$. Таким образом можно считать например после первого вопроса что промежуток в котором было загаднно число был либо $[1, x-1]$, либо $[x, 1000]$ (в зависимости от полученного ответа). 

Выгоднее всего спросить $x = 500$ или $x = 501$, потому что в таком случае длина наибольшего из двух промежутков будет наименьшая (мы хотим минимизировать максимум среди длин двух отрезков). Если далее применить на оставшемся промежутке описанный выше алгоритм, то получится $500 + 1$ вопрос нам всего понадобится сделать. Уже добились уменьшения почти в $2$ раза. 

Отметим, что числа $500$ и $501$ взяты не просто так, а являются серединой исходного отрезка. Давай обозначим границу поиска, где лежит загаданное число как $[l, r]$, где в нашем случае $l = 1$ и $r = 1000$. Однако, далее для удобства мы будем работать не с отрезком $[l, r]$ ($l$ и $r$ включены в промежуток), а с полуинтервалом $[l, r)$ ($l$ включена в промежуток, а $r$ нет). Тогда $l = 1$, $r = 1001$. Использование полуинтервалов упрощает расчёты, так например длина промежутка тогда вычисляется как $r - l$, вместо $r - l + 1$. Помимо [отрезков и полуинтервалов существуют ещё и интервалы](https://ru.wikipedia.org/wiki/Промежуток_(математика)), но они обычно не удобны для использования в программировании. 

Итак, чтобы вычислить значение серидины полуинтервала ($m$), мы можем прибавить к левой границе половину длины полуинтервала ($m = l + (r - l)/2$), или ещё лучше, заметить что это на самом деле среднее арифметическое границ полуинтервала ($m = (l + r)/2$). Таким образом, в нашем случае $m = (1 + 1001) / 2 = 501$. Отметим, что мы будем производить целочисленное деление, поскольку работаем только в целых числах.

Наконец, чтобы достичь серьёзного улучшения по асимптотике алгоритма, будем делить промежуток на $2$ равные (или с разницей в длине на $1$) части, пока длина не станет равной $1$. Проследим как будет уменьшаться длина промежутка в нашем случае:
$$1000 \rightarrow 500 \rightarrow 250 \rightarrow 125 \rightarrow 63 \rightarrow 32 \rightarrow 16 \rightarrow 8 \rightarrow 4 \rightarrow 2 \rightarrow 1 $$

Таким образом, вместо $1000$ вопросов нам теперь достаточно делать не более $10$ вопросов, каждый раз деля промежуток на котором находится ответ на $2$ равные части. Это и есть бинарный (двоичный) поиск. 

Пусть длина изначального промежутка равна $len$. Для оценки времени работы алгоритма необходимо посчитать, сколько раз мы можем делить $len$ на $2$, пока оно не будет больше $1$. Это еквивалентно решению уравнения $2^x = len$. В математике решение уравнения вида $a^x = b$, где $a$ и $b$ некоторые константы, обозначается как $\log_ab$, что читается как *логарифм* $a$ по основанию $b$ (говоря простыми словами, в какую степень надо возвести $a$ чтобы получить $b$). 

Таким образом, количество операций бинарного поиска можно оценить как $\mathcal{O}(\log_2 len)$. Можно показать, что $\frac{\log_ab}{\log_cb} = const$, Потому основание логарифма можно не уточнять и писать в асимптотике $\mathcal{O}(\log len)$.

Наконец, заметим, что логарифм является медленно-растущей функцией. Так например, $\log_2 10^9 < 30$, и если с тривиальным алгоритмом ребятам могло не хватить и жизни, дабы закончить игру, то с бинарный поиск на всё про всё уйдёт несколько минут.

