# Бинарный и тернарный поиск, 2 указателя

## Бинарный поиск

Рассмотрим следующую игру. Вася загадывает целое число от $1$ до $1000$. Петя в свою очередь может выбирать любое целое $x$ и спрашивать у Васи: «Загаданное тобой число меньше $x$?». Вася отвечает «Нет» или «Да». Петя хочет как можно быстрее выиграть в эту игру. Как ему это сделать? 

Простым решением будет спрашивать например по очереди числа $1$, $2$, $3$, и т.д., пока Вася не ответит «Да». Тогда ответом будет последнее названное число $-1$. Однако игра будет длитя долго, и в худшем случае необходимо будет перебрать все $1000$ чисел. А если загаданное число было бы например в промежутке от $1$ до $10^9$, то ребятам возможно не хватило бы даже целой жизни, чтобы завершить игру. Время работы такого алгоритмы оценивается как $\mathcal{O}(len)$, где $len$ - длина промежутка, на котором было загадано число.

Поэтому сделаем важное наблюдение. Если мы спросили некоторый $x$ и получили ответ «Нет», то загаданное число $\ge x$. Иначе, загаданное число $< x$. Таким образом можно считать например после первого вопроса что промежуток в котором было загаднно число был либо $[1, x-1]$, либо $[x, 1000]$ (в зависимости от полученного ответа). 

Выгоднее всего спросить $x = 500$ или $x = 501$, потому что в таком случае длина наибольшего из двух промежутков будет наименьшая (мы хотим минимизировать максимум среди длин двух отрезков). Если далее применить на оставшемся промежутке описанный выше алгоритм, то получится $500 + 1$ вопрос нам всего понадобится сделать. Уже добились уменьшения почти в $2$ раза. 

Отметим, что числа $500$ и $501$ взяты не просто так, а являются серединой исходного отрезка. Давай обозначим границу поиска, где лежит загаданное число как $[l, r]$, где в нашем случае $l = 1$ и $r = 1000$. Однако, далее для удобства мы будем работать не с отрезком $[l, r]$ ($l$ и $r$ включены в промежуток), а с полуинтервалом $[l, r)$ ($l$ включена в промежуток, а $r$ нет). Тогда $l = 1$, $r = 1001$. Использование полуинтервалов упрощает расчёты, так например длина промежутка тогда вычисляется как $r - l$, вместо $r - l + 1$. Помимо [отрезков и полуинтервалов существуют ещё и интервалы](https://ru.wikipedia.org/wiki/Промежуток_(математика)), но они обычно не удобны для использования в программировании. 

Итак, чтобы вычислить значение серидины полуинтервала ($m$), мы можем прибавить к левой границе половину длины полуинтервала ($m = l + (r - l)/2$), или ещё лучше, заметить что это на самом деле среднее арифметическое границ полуинтервала ($m = (l + r)/2$). Таким образом, в нашем случае $m = (1 + 1001) / 2 = 501$. Отметим, что мы будем производить целочисленное деление, поскольку работаем только в целых числах.

Наконец, чтобы достичь серьёзного улучшения по асимптотике алгоритма, будем делить промежуток на $2$ равные (или с разницей в длине на $1$) части, пока длина не станет равной $1$. Проследим как будет уменьшаться длина промежутка в нашем случае:
$$1000 \rightarrow 500 \rightarrow 250 \rightarrow 125 \rightarrow 63 \rightarrow 32 \rightarrow 16 \rightarrow 8 \rightarrow 4 \rightarrow 2 \rightarrow 1 $$

Таким образом, вместо $1000$ вопросов нам теперь достаточно делать не более $10$ вопросов, каждый раз деля промежуток на котором находится ответ на $2$ равные части. Это и есть бинарный (двоичный) поиск. 

Пусть длина изначального промежутка равна $len$. Для оценки времени работы алгоритма необходимо посчитать, сколько раз мы можем делить $len$ на $2$, пока оно не будет больше $1$. Это еквивалентно решению уравнения $2^x = len$. В математике решение уравнения вида $a^x = b$, где $a$ и $b$ некоторые константы, обозначается как $\log_ab$, что читается как *логарифм* $a$ по основанию $b$ (говоря простыми словами, в какую степень надо возвести $a$ чтобы получить $b$). 

Таким образом, количество операций бинарного поиска можно оценить как $\mathcal{O}(\log_2 len)$. Можно показать, что $\frac{\log_ab}{\log_cb} = const$, Потому основание логарифма можно не уточнять и писать в асимптотике $\mathcal{O}(\log len)$.

Наконец, заметим, что логарифм является медленно-растущей функцией. Так например, $\log_2 10^9 < 30$, и если с тривиальным алгоритмом ребятам могло не хватить и жизни, дабы закончить игру, то с бинарным поиском на всё про всё уйдёт несколько минут.

Пример кода по задаче:

```cpp
    int l = 1; // l включительно
    int r = 1001; // r не включительно, поэтому r > 1000
    while (r - l > 1) { // r - l = длина полуинтервала
        int m = (l + r) >> 1; // ">> 1" эквивалентно "/ 2". m - середина полуинтервала
        if (загадано меньше m) {
            r = m;
        } else {
            l = m;
        }
    }

    // l - ответ загаданное число. Ответом в других задачах/реализациях будет необязательно l, а например r (l + 1). думайте о том, где именно лежит ответ, после выполенния бинпоиска.
```

## Применимость бинарного поиска

Данный алгоритм является одним из самых важных и часто применямых. Его можно использовать, например, для решения таких задач, как:

* Проверка наличия определённого числа, в отсортированном массиве.
* Поиск индекса элемента в отсортированном массиве.
* Поиск слова в словаре.
* Задана прямая $y = k\cdot x + b$ ($k \neq 0$), найти при каком $x$ достигается $y = a$.

### Вещественный бинарный поиск

Остановимся на последнем пункте поподробнее. Ниже приведён графический пример такой задачи.

![](lines_intr.png)

Понятно, что такая задача имеет простое аналитическое решение за $\mathcal{O}(1)$. простым решением уравнения вида $a = k\cdot x + b$. Но задача имеет и решение методом бинарного поиска. 

Возьмём $l$ заведомо не больше искомого $x$ и $r$ заведомо не меньше $x$. Тогда будем делить отрезок пополам, проверяя больше ли $y = m \cdot x + b$ чем $a$, или нет, и соответсвующим образом сдвигая одну из границ к центру отрезка. 

Теоретически, такое решение будет работать бесконечно долго, ведь на множестве вещественных чисел мы можем уменьшать длину отрезка в $2$ раза бесконечно долго. Однако, в реальных задачах обычно необходимо найти ответ с определённой точностью, которая достижима с использованием встроенных численных типов данных с плавающей точкой (`double`, `long double`, `float` и т.д.). Поэтому, будем уменьшать отрезок в $2$ раза до тех пор, пока его длина не будет меньше чем разрешённая погрешность. 

Пример кода для этой задачи:

```cpp
    // удобно в задачах на бинарный поиск выносить функцию проверки в отдельную сущность (иногда она используется несколько раз в коде, например при выводе ответа)
    double f(double x) {
        return k * x + b;
    }

    ...

    const double eps = 1e-9; // разрешённая погрешность
    double l = -1e100; // -(10^100)
    double r = 1e100; // 10^100
    while (r - l > eps) {
        double m = (l + r) / 2;
        if (f(m) < a) {
            l = m;
        } else {
            r = m;
        }
    }

    // ответ - любое число в промежутке [l, r]
```

Вместо `while (r - l > eps)` можно написать например `for (int _ = 0; _ < 200; _++)`, делая бинарный поиск не до определённой длины отрезка, а стараясь получить как можно меньшую длину за счёт большого числа итераций. Из минусов такого подхода $-$ долгое время выполнения, но когда это не критично, он является предпочительным. 

### Общий вид задач, где применим бинпоиск

Познакомимся с понятием монотонной функции. Функция является монотонной, если для всех $x_1 < x_2$ всегда верно либо $f(x_1) \le f(x_2)$ (монотонно неубывающая ф-я), либо $f(x_1) \ge f(x_2)$ (монотонно невозрастающая ф-я).

![](monotonic-functions.png)

Бинарный поиск применим для поиска значения параметра ($x$) монотонной функции ($f(x)$), при котором она принимает определённое значение ($f(x) = a$).

Примеры таких функций:

* $f(x) = x^2$ (Для $x \ge 0$). С помощью такой функции можно для произвольного заданного положительного числа $n$ найти его корень с помощью бинарного поиска (что будет иметь большую точность, чем использование встроенной функции `sqrt`). 

* $f(x) = x^3$ (Для всех $x$).

* $f(x) = \frac{1}{x}$ (Для всех $x > 0$).
