# Динамическое ДО. Персистентное ДО.

В [прошлой статье](https://github.com/kolychestiy/olymp/tree/main/segment_tree "базовое дерево отрезков") мы изучили что такое дерево отрезков, простой и быстрый способ его реализации, операции модификации на отрезке, способы применения. Перед изучением данной статьи рекомендуется приобрести знание этих вещей. 

Обозначения: 
1. $n$ $-$ размер массива
2. $q$ $-$ число запросов.
3. $a$ $-$ массив чисел размера $n$.

### Альтернативный способ реализации ДО

Если раньше, мы хранили только массив $t$ и красиво занумеровали вершины (у вершины $v$ дети это $2 \cdot v$ и $2 \cdot v + 1$), то сейчас сделаем некоторый шаг назад, чтобы потом сделать 2 вперёд. В рамках этой статьи нас будет интересовать наивная реализация, в которой мы для каждой вершины будем хранить её левого и правого ребёнка, в связи с чем напрашивается в том числе и создание отдельной стркуктуры для вершины:

```cpp
struct Node {
  Node *l = NULL;
  Node *r = NULL;
  int sum = 0;
};
```

Если что то из кода выше непонятно, то сначала стоит изучить [структуры в C++](https://metanit.com/cpp/tutorial/5.8.php) и [указатели](https://metanit.com/cpp/tutorial/4.1.php). В таком случае соответсвующим образом изменятся `build`, `get` и `upd`:

```cpp
const int SZ = 1 << 17;
void build(Node *cur, int l = 0, int r = SZ){ 
    if (r - l == 1) { // лист
        // т.к. cur - указатель, то для обращения к левому ребёнку надо писать (*cur).sum
        // для таких целей в C++ есть специальный синтаксический сахар - cur->sum
        cur->sum = a[l];
        return;
    }

    int mid = (l + r) >> 1;
    cur->l = new Node; 
    build(cur->l, l, mid);
    cur->r = new Node;
    build(cur->r, mid, r);
    cur->sum = cur->l->sum + cur->r->sum;
}
```

```cpp
void upd(int i, int x, Node *cur, int l = 0, int r = SZ){
    if (i < l || r <= i){ // i не в ходит в [l, r)
        return;
    }

    if (r - l == 1){
        cur->sum = x;
        return;
    }

    int mid = (l + r) >> 1;
    upd(i, x, cur->l, l, mid);
    upd(i, x, cur->r, mid, r);
    cur->sum = cur->l->sum + cur->r->sum;
}
```

```cpp
int get(int ql, int qr, Node *cur, int l = 0, int r = SZ){
    if (qr <= l || r <= ql){ // [l, r) не пересекатся с [ql, qr)
        return 0;
    }

    if (ql <= l && r <= qr){ // [l, r) полностью входит в [ql, qr)
        return cur->sum;
    }

    int mid = (l + r) >> 1;
    return get(ql, qr, cur->l, l, mid) + get(ql, qr, cur->r, mid, r);
}
```

Остается только создать указатель на корень и сохранить его в переменной, для вставки в вызовы любой функции:

```cpp
  Node *root = new Node;
```

Минусы данной реализации очевидны - нам нужно больше памяти для хранения рёбер дерева, и также стоит ожидать несколько большее время работы, в виду скачков по памяти (есть реализации без указателей где эта проблема устраняется). Однако, как уже было сказано, мы пошли на столь отчаяный шаг чтобы сорвать куш. Данная реализация позволяет делать множество очень мощных модификаций.

## Персистентное ДО

Персистентные структуры данных (англ. persistent data structure) — это структуры данных, которые при внесении в них каких-то изменений сохраняют все свои предыдущие состояния и доступ к этим состояниям.

Говоря более простым языком: После каждого `upd` мы хотим сохранять старую версию ДО, чтобы можно было с ней работать, в том числе делать на ней `get`. 

Для лучшего понимания, рассмотрим задачу. [Условие задачи в контесте](https://codeforces.com/group/fgAhCx6Kz6/contest/506298/problem/A "based contest. task A"). Приведём сжатое условие и здесь:

Нужно находить $k$-ю порядковую статистику среди $a_l, a_{l+1}, \ldots, a_r$.




Это можно было бы делать тривиальным образом, создавая после каждого `upd` новое ДО, что занимало бы $\mathcal{O}(n \cdot q)$ времени и памяти.
