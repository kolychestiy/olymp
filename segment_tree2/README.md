# Динамическое ДО. Персистентное ДО.

В [прошлой статье](https://github.com/kolychestiy/olymp/tree/main/segment_tree "базовое дерево отрезков") мы изучили что такое дерево отрезков, простой и быстрый способ его реализации, операции модификации на отрезке, способы применения. Перед изучением данной статьи рекомендуется приобрести знание этих вещей. 

Обозначения: 
1. $n$ $-$ размер массива
2. $q$ $-$ число запросов.
3. $a$ $-$ массив чисел размера $n$.
4. целевая функция $-$ функция, которая вычисляется на ДО, например сумма, минимум и т.д.

### Альтернативный способ реализации ДО

Если раньше, мы хранили только массив $t$ и красиво занумеровали вершины (у вершины $v$ дети это $2 \cdot v$ и $2 \cdot v + 1$), то сейчас сделаем некоторый шаг назад, чтобы потом сделать 2 вперёд. В рамках этой статьи нас будет интересовать наивная реализация, в которой мы для каждой вершины будем хранить её левого и правого ребёнка, в связи с чем напрашивается в том числе и создание отдельной стркуктуры для вершины:

```cpp
struct Node {
  Node *l = NULL;
  Node *r = NULL;
  int sum = 0;
};
```

Если что то из кода выше непонятно, то сначала стоит изучить [структуры в C++](https://metanit.com/cpp/tutorial/5.8.php) и [указатели](https://metanit.com/cpp/tutorial/4.1.php). В таком случае соответсвующим образом изменятся `build`, `get` и `upd`:

```cpp
const int SZ = 1 << 17;
void build(Node *cur, int l = 0, int r = SZ){ 
    if (r - l == 1) { // лист
        // т.к. cur - указатель, то для обращения к левому ребёнку надо писать (*cur).sum
        // для таких целей в C++ есть специальный синтаксический сахар - cur->sum
        cur->sum = a[l];
        return;
    }

    int mid = (l + r) >> 1;
    cur->l = new Node; 
    build(cur->l, l, mid);
    cur->r = new Node;
    build(cur->r, mid, r);
    cur->sum = cur->l->sum + cur->r->sum;
}
```

```cpp
void upd(int i, int x, Node *cur, int l = 0, int r = SZ){
    if (i < l || r <= i){ // i не в ходит в [l, r)
        return;
    }

    if (r - l == 1){
        cur->sum = x;
        return;
    }

    int mid = (l + r) >> 1;
    upd(i, x, cur->l, l, mid);
    upd(i, x, cur->r, mid, r);
    cur->sum = cur->l->sum + cur->r->sum;
}
```

```cpp
int get(int ql, int qr, Node *cur, int l = 0, int r = SZ){
    if (qr <= l || r <= ql){ // [l, r) не пересекатся с [ql, qr)
        return 0;
    }

    if (ql <= l && r <= qr){ // [l, r) полностью входит в [ql, qr)
        return cur->sum;
    }

    int mid = (l + r) >> 1;
    return get(ql, qr, cur->l, l, mid) + get(ql, qr, cur->r, mid, r);
}
```

Остается только создать указатель на корень и сохранить его в переменной, для вставки в вызовы любой функции:

```cpp
  Node *root = new Node;
```

Минусы данной реализации очевидны - нам нужно больше памяти для хранения рёбер дерева, и также стоит ожидать несколько большее время работы, в виду скачков по памяти (есть реализации без указателей где эта проблема устраняется). Однако, как уже было сказано, мы пошли на столь отчаяный шаг чтобы сорвать куш. Данная реализация позволяет делать множество очень мощных модификаций.

## Персистентное ДО

Персистентные структуры данных (англ. persistent data structure) — это структуры данных, которые при внесении в них каких-то изменений сохраняют все свои предыдущие состояния и доступ к этим состояниям.

Говоря более простым языком: После каждого `upd` мы хотим сохранять старую версию ДО, чтобы можно было с ней работать, в том числе делать на ней `get`. 

Для лучшего понимания, рассмотрим задачу. [Условие задачи в контесте](https://codeforces.com/group/fgAhCx6Kz6/contest/506298/problem/A "based contest. task A"). Приведём сжатое условие и здесь: Есть запросы вида $[l, r]$. Нужно находить $k$-ю порядковую статистику среди $a_l, a_{l+1}, \ldots, a_r$.

Для начала научимся решать задачу, описанную в [прошлой статье](https://github.com/kolychestiy/olymp/tree/main/segment_tree "базовое дерево отрезков") в разделе `"Спуск" по дереву.`. Представим теперь, что мы для каждого запроса построили такое ДО только на элементах из отрезка $[l, r]$. Тогда мы умеем отвечать на запрос за $\mathcal{O}(\log n)$. 

Введём операцию сложения двух ДО. $t_{fi}$ и $t_{se}$ $-$ 2 ДО одинакового размера, тогда $t_{res} = t_{fi} + t_{se}$ это ДО такого же размера как и слагаемые, при этом $t_{res}[v] = t_{fi}[v] + t_{se}[v]$ для любог $v$.

Обозначим ДО для отрезка $[l, r]$ как $t_{l,r}$, а ДО для отрезка $[0, r]$ как $t_r$. Справедливо следующее удтверждение: $t_{l,r} = t_r - t_{l - 1}$. Таким образом, Достаточно построить $t_r$, для всех $0 \le r \le n$, и через них выражать любое $t_{l, r}$. Это по сути есть ничто иное, как массив префиксных сумм, элементами которого являются ДО. В тривиальной реализации это займет $\mathcal{O}(n^2)$ времени и столько же памяти.

Поэтому давайте мы не будем строить новое ДО каждый раз, а будем по хитрому использовать ДО построенное на предыдущем шаге. $t_r = t_{r-1} + t_{r,r}$, а поскольку $t_{r,r}$ $-$ это по сути один раз выполненная функция `upd`, то $t_{r,r}$ имеет $\mathcal{O}(\log n)$ ненулевых вершин, а следовательно $t_r$ отличается от $t_{r-1}$ не более чем в $\mathcal{O}(\log n)$ вершинах. Поэтому, $t_r$ может подобно паразиту использовать для своей жизни $t_{r-1}$, создавая на нём не более $\mathcal{O}(\log n)$ ~~раковых клеток~~ новых вершин. Этими вершинами будут в точности те вершины, которые мы изменили. Они изначально будут полностью копировать своих предшественников, но потом поменяют своё значение целевой функции(суммы) и ссылки на каких то детей, которые тоже могли быть обновленны. Таким образом, Учитывая то, что мы написали ДО на указателях, для того чтобы работать с $t_r$ достаточно хранить указатель на его корень, которые был получен после внесения изменения в $t_{r-1}$.

